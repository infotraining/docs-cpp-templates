
<!DOCTYPE html>


<html lang="en" data-content_root="./" >

  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" /><meta name="viewport" content="width=device-width, initial-scale=1" />

    <title>Szablony klas &#8212; Book title</title>
  
  
  
  <script data-cfasync="false">
    document.documentElement.dataset.mode = localStorage.getItem("mode") || "";
    document.documentElement.dataset.theme = localStorage.getItem("theme") || "";
  </script>
  
  <!-- Loaded before other Sphinx assets -->
  <link href="_static/styles/theme.css?digest=3ee479438cf8b5e0d341" rel="stylesheet" />
<link href="_static/styles/bootstrap.css?digest=3ee479438cf8b5e0d341" rel="stylesheet" />
<link href="_static/styles/pydata-sphinx-theme.css?digest=3ee479438cf8b5e0d341" rel="stylesheet" />

  
  <link href="_static/vendor/fontawesome/6.5.2/css/all.min.css?digest=3ee479438cf8b5e0d341" rel="stylesheet" />
  <link rel="preload" as="font" type="font/woff2" crossorigin href="_static/vendor/fontawesome/6.5.2/webfonts/fa-solid-900.woff2" />
<link rel="preload" as="font" type="font/woff2" crossorigin href="_static/vendor/fontawesome/6.5.2/webfonts/fa-brands-400.woff2" />
<link rel="preload" as="font" type="font/woff2" crossorigin href="_static/vendor/fontawesome/6.5.2/webfonts/fa-regular-400.woff2" />

    <link rel="stylesheet" type="text/css" href="_static/pygments.css?v=03e43079" />
    <link rel="stylesheet" type="text/css" href="_static/styles/sphinx-book-theme.css?v=a3416100" />
    <link rel="stylesheet" type="text/css" href="_static/togglebutton.css?v=13237357" />
    <link rel="stylesheet" type="text/css" href="_static/copybutton.css?v=76b2166b" />
    <link rel="stylesheet" type="text/css" href="_static/mystnb.8ecb98da25f57f5357bf6f572d296f466b2cfe2517ffebfabe82451661e28f02.css" />
    <link rel="stylesheet" type="text/css" href="_static/sphinx-thebe.css?v=4fa983c6" />
    <link rel="stylesheet" type="text/css" href="_static/sphinx-design.min.css?v=95c83b7e" />
    <link rel="stylesheet" type="text/css" href="_static/custom.css?v=78a291d3" />
  
  <!-- Pre-loaded scripts that we'll load fully later -->
  <link rel="preload" as="script" href="_static/scripts/bootstrap.js?digest=3ee479438cf8b5e0d341" />
<link rel="preload" as="script" href="_static/scripts/pydata-sphinx-theme.js?digest=3ee479438cf8b5e0d341" />
  <script src="_static/vendor/fontawesome/6.5.2/js/all.min.js?digest=3ee479438cf8b5e0d341"></script>

    <script src="_static/documentation_options.js?v=9eb32ce0"></script>
    <script src="_static/doctools.js?v=9a2dae69"></script>
    <script src="_static/sphinx_highlight.js?v=dc90522c"></script>
    <script src="_static/clipboard.min.js?v=a7894cd8"></script>
    <script src="_static/copybutton.js?v=f281be69"></script>
    <script src="_static/scripts/sphinx-book-theme.js?v=887ef09a"></script>
    <script>let toggleHintShow = 'Click to show';</script>
    <script>let toggleHintHide = 'Click to hide';</script>
    <script>let toggleOpenOnPrint = 'true';</script>
    <script src="_static/togglebutton.js?v=4a39c7ea"></script>
    <script>var togglebuttonSelector = '.toggle, .admonition.dropdown';</script>
    <script src="_static/design-tabs.js?v=f930bc37"></script>
    <script async="async" src="https://www.googletagmanager.com/gtag/js?id=G-FDEL95YPHW"></script>
    <script>
                window.dataLayer = window.dataLayer || [];
                function gtag(){ dataLayer.push(arguments); }
                gtag('js', new Date());
                gtag('config', 'G-FDEL95YPHW');
            </script>
    <script>const THEBE_JS_URL = "https://unpkg.com/thebe@0.8.2/lib/index.js"; const thebe_selector = ".thebe,.cell"; const thebe_selector_input = "pre"; const thebe_selector_output = ".output, .cell_output"</script>
    <script async="async" src="_static/sphinx-thebe.js?v=c100c467"></script>
    <script>var togglebuttonSelector = '.toggle, .admonition.dropdown';</script>
    <script>
                window.dataLayer = window.dataLayer || [];
                function gtag(){ dataLayer.push(arguments); }
                gtag('js', new Date());
                gtag('config', 'G-FDEL95YPHW');
            </script>
    <script>const THEBE_JS_URL = "https://unpkg.com/thebe@0.8.2/lib/index.js"; const thebe_selector = ".thebe,.cell"; const thebe_selector_input = "pre"; const thebe_selector_output = ".output, .cell_output"</script>
    <script>DOCUMENTATION_OPTIONS.pagename = 'class-templates';</script>
    <link rel="index" title="Index" href="genindex.html" />
    <link rel="search" title="Search" href="search.html" />
    <link rel="next" title="Aliasy szablonów" href="aliases.html" />
    <link rel="prev" title="Szablony funkcji" href="function-templates.html" />
  <meta name="viewport" content="width=device-width, initial-scale=1"/>
  <meta name="docsearch:language" content="en"/>
  </head>
  
  
  <body data-bs-spy="scroll" data-bs-target=".bd-toc-nav" data-offset="180" data-bs-root-margin="0px 0px -60%" data-default-mode="">

  
  
  <div id="pst-skip-link" class="skip-link d-print-none"><a href="#main-content">Skip to main content</a></div>
  
  <div id="pst-scroll-pixel-helper"></div>
  
  <button type="button" class="btn rounded-pill" id="pst-back-to-top">
    <i class="fa-solid fa-arrow-up"></i>Back to top</button>

  
  <input type="checkbox"
          class="sidebar-toggle"
          id="pst-primary-sidebar-checkbox"/>
  <label class="overlay overlay-primary" for="pst-primary-sidebar-checkbox"></label>
  
  <input type="checkbox"
          class="sidebar-toggle"
          id="pst-secondary-sidebar-checkbox"/>
  <label class="overlay overlay-secondary" for="pst-secondary-sidebar-checkbox"></label>
  
  <div class="search-button__wrapper">
    <div class="search-button__overlay"></div>
    <div class="search-button__search-container">
<form class="bd-search d-flex align-items-center"
      action="search.html"
      method="get">
  <i class="fa-solid fa-magnifying-glass"></i>
  <input type="search"
         class="form-control"
         name="q"
         id="search-input"
         placeholder="Search this book..."
         aria-label="Search this book..."
         autocomplete="off"
         autocorrect="off"
         autocapitalize="off"
         spellcheck="false"/>
  <span class="search-button__kbd-shortcut"><kbd class="kbd-shortcut__modifier">Ctrl</kbd>+<kbd>K</kbd></span>
</form></div>
  </div>

  <div class="pst-async-banner-revealer d-none">
  <aside id="bd-header-version-warning" class="d-none d-print-none" aria-label="Version warning"></aside>
</div>

  
    <header class="bd-header navbar navbar-expand-lg bd-navbar d-print-none">
    </header>
  

  <div class="bd-container">
    <div class="bd-container__inner bd-page-width">
      
      
      
      <div class="bd-sidebar-primary bd-sidebar">
        

  
  <div class="sidebar-header-items sidebar-primary__section">
    
    
    
    
  </div>
  
    <div class="sidebar-primary-items__start sidebar-primary__section">
        <div class="sidebar-primary-item">

  

<a class="navbar-brand logo" href="index.html">
  
  
  
  
  
    
    
      
    
    
    <img src="_static/logo.png" class="logo__image only-light" alt="Book title - Home"/>
    <script>document.write(`<img src="_static/logo.png" class="logo__image only-dark" alt="Book title - Home"/>`);</script>
  
  
</a></div>
        <div class="sidebar-primary-item">

 <script>
 document.write(`
   <button class="btn navbar-btn search-button-field search-button__button" title="Search" aria-label="Search" data-bs-placement="bottom" data-bs-toggle="tooltip">
    <i class="fa-solid fa-magnifying-glass"></i>
    <span class="search-button__default-text">Search</span>
    <span class="search-button__kbd-shortcut"><kbd class="kbd-shortcut__modifier">Ctrl</kbd>+<kbd class="kbd-shortcut__modifier">K</kbd></span>
   </button>
 `);
 </script></div>
        <div class="sidebar-primary-item"><nav class="bd-links bd-docs-nav" aria-label="Main">
    <div class="bd-toc-item navbar-nav active">
        
        <ul class="nav bd-sidenav bd-sidenav__home-link">
            <li class="toctree-l1">
                <a class="reference internal" href="index.html">
                    Programowanie generyczne w C++
                </a>
            </li>
        </ul>
        <ul class="current nav bd-sidenav">
<li class="toctree-l1 current active has-children"><a class="reference internal" href="templates.html">Szablony</a><details open="open"><summary><span class="toctree-toggle" role="presentation"><i class="fa-solid fa-chevron-down"></i></span></summary><ul class="current">
<li class="toctree-l2"><a class="reference internal" href="function-templates.html">Szablony funkcji</a></li>
<li class="toctree-l2 current active"><a class="current reference internal" href="#">Szablony klas</a></li>
<li class="toctree-l2"><a class="reference internal" href="aliases.html">Aliasy szablonów</a></li>
<li class="toctree-l2"><a class="reference internal" href="variable-templates.html">Szablony zmiennych</a></li>
<li class="toctree-l2"><a class="reference internal" href="template-instantiation.html">Proces tworzenia instancji szablonu</a></li>
<li class="toctree-l2"><a class="reference internal" href="dependent-names.html">Nazwy zależne od typów</a></li>
</ul>
</details></li>
<li class="toctree-l1"><a class="reference internal" href="type-traits.html">Klasy cech typów - biblioteka &lt;type_traits&gt;</a></li>
<li class="toctree-l1"><a class="reference internal" href="generic-functions.html">Funkcje szablonowe z auto</a></li>
<li class="toctree-l1"><a class="reference internal" href="sfinae.html">SFINAE - enable_if</a></li>
<li class="toctree-l1"><a class="reference internal" href="concepts.html">Koncepty i ograniczenia szablonów</a></li>
<li class="toctree-l1"><a class="reference internal" href="variadic-templates.html">Variadic templates</a></li>
<li class="toctree-l1"><a class="reference internal" href="fold-expressions.html">Fold expressions w C++17</a></li>
<li class="toctree-l1"><a class="reference internal" href="tuples.html">Krotki w C++</a></li>
<li class="toctree-l1"><a class="reference internal" href="index-sequences.html">Sekwencje indeksów</a></li>
</ul>

    </div>
</nav></div>
    </div>
  
  
  <div class="sidebar-primary-items__end sidebar-primary__section">
  </div>
  
  <div id="rtd-footer-container"></div>


      </div>
      
      <main id="main-content" class="bd-main" role="main">
        
        

<div class="sbt-scroll-pixel-helper"></div>

          <div class="bd-content">
            <div class="bd-article-container">
              
              <div class="bd-header-article d-print-none">
<div class="header-article-items header-article__inner">
  
    <div class="header-article-items__start">
      
        <div class="header-article-item"><button class="sidebar-toggle primary-toggle btn btn-sm" title="Toggle primary sidebar" data-bs-placement="bottom" data-bs-toggle="tooltip">
  <span class="fa-solid fa-bars"></span>
</button></div>
      
    </div>
  
  
    <div class="header-article-items__end">
      
        <div class="header-article-item">

<div class="article-header-buttons">





<div class="dropdown dropdown-source-buttons">
  <button class="btn dropdown-toggle" type="button" data-bs-toggle="dropdown" aria-expanded="false" aria-label="Source repositories">
    <i class="fab fa-github"></i>
  </button>
  <ul class="dropdown-menu">
      
      
      
      <li><a href="https://github.com/infotraining/docs-template" target="_blank"
   class="btn btn-sm btn-source-repository-button dropdown-item"
   title="Source repository"
   data-bs-placement="left" data-bs-toggle="tooltip"
>
  

<span class="btn__icon-container">
  <i class="fab fa-github"></i>
  </span>
<span class="btn__text-container">Repository</span>
</a>
</li>
      
      
      
      
      <li><a href="https://github.com/infotraining/docs-template/issues/new?title=Issue%20on%20page%20%2Fclass-templates.html&body=Your%20issue%20content%20here." target="_blank"
   class="btn btn-sm btn-source-issues-button dropdown-item"
   title="Open an issue"
   data-bs-placement="left" data-bs-toggle="tooltip"
>
  

<span class="btn__icon-container">
  <i class="fas fa-lightbulb"></i>
  </span>
<span class="btn__text-container">Open issue</span>
</a>
</li>
      
  </ul>
</div>






<div class="dropdown dropdown-download-buttons">
  <button class="btn dropdown-toggle" type="button" data-bs-toggle="dropdown" aria-expanded="false" aria-label="Download this page">
    <i class="fas fa-download"></i>
  </button>
  <ul class="dropdown-menu">
      
      
      
      <li><a href="_sources/class-templates.md" target="_blank"
   class="btn btn-sm btn-download-source-button dropdown-item"
   title="Download source file"
   data-bs-placement="left" data-bs-toggle="tooltip"
>
  

<span class="btn__icon-container">
  <i class="fas fa-file"></i>
  </span>
<span class="btn__text-container">.md</span>
</a>
</li>
      
      
      
      
      <li>
<button onclick="window.print()"
  class="btn btn-sm btn-download-pdf-button dropdown-item"
  title="Print to PDF"
  data-bs-placement="left" data-bs-toggle="tooltip"
>
  

<span class="btn__icon-container">
  <i class="fas fa-file-pdf"></i>
  </span>
<span class="btn__text-container">.pdf</span>
</button>
</li>
      
  </ul>
</div>




<button onclick="toggleFullScreen()"
  class="btn btn-sm btn-fullscreen-button"
  title="Fullscreen mode"
  data-bs-placement="bottom" data-bs-toggle="tooltip"
>
  

<span class="btn__icon-container">
  <i class="fas fa-expand"></i>
  </span>

</button>



<script>
document.write(`
  <button class="btn btn-sm navbar-btn theme-switch-button" title="light/dark" aria-label="light/dark" data-bs-placement="bottom" data-bs-toggle="tooltip">
    <span class="theme-switch nav-link" data-mode="light"><i class="fa-solid fa-sun fa-lg"></i></span>
    <span class="theme-switch nav-link" data-mode="dark"><i class="fa-solid fa-moon fa-lg"></i></span>
    <span class="theme-switch nav-link" data-mode="auto"><i class="fa-solid fa-circle-half-stroke fa-lg"></i></span>
  </button>
`);
</script>


<script>
document.write(`
  <button class="btn btn-sm navbar-btn search-button search-button__button" title="Search" aria-label="Search" data-bs-placement="bottom" data-bs-toggle="tooltip">
    <i class="fa-solid fa-magnifying-glass fa-lg"></i>
  </button>
`);
</script>
<button class="sidebar-toggle secondary-toggle btn btn-sm" title="Toggle secondary sidebar" data-bs-placement="bottom" data-bs-toggle="tooltip">
    <span class="fa-solid fa-list"></span>
</button>
</div></div>
      
    </div>
  
</div>
</div>
              
              

<div id="jb-print-docs-body" class="onlyprint">
    <h1>Szablony klas</h1>
    <!-- Table of contents -->
    <div id="print-main-content">
        <div id="jb-print-toc">
            
            <div>
                <h2> Contents </h2>
            </div>
            <nav aria-label="Page">
                <ul class="visible nav section-nav flex-column">
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#podstawowa-skladnia">Podstawowa składnia</a><ul class="nav section-nav flex-column">
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#definicja-szablonu-klasy">Definicja szablonu klasy</a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#implementacja-funkcji-skladowych-poza-cialem-klasy">Implementacja funkcji składowych poza ciałem klasy</a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#tworzenie-instancji-szablonu-klasy">Tworzenie instancji szablonu klasy</a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#przyklad-uzycia">Przykład użycia</a></li>
</ul>
</li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#parametry-szablonow-klas">Parametry szablonów klas</a><ul class="nav section-nav flex-column">
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#parametry-typu">1. Parametry typu</a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#parametry-niebedace-typami-nttp">2. Parametry niebędące typami - NTTP</a><ul class="nav section-nav flex-column">
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#dopuszczalne-parametry-nttp">Dopuszczalne parametry NTTP</a></li>
</ul>
</li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#szablony-jako-parametry-szablonow">3. Szablony jako parametry szablonów</a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#parametry-domyslne">Parametry domyślne</a></li>
</ul>
</li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#specjalizacja-szablonow-klas">Specjalizacja szablonów klas</a><ul class="nav section-nav flex-column">
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#pelna-specjalizacja-szablonu-klasy">Pełna specjalizacja szablonu klasy</a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#specjalizacja-czesciowa-szablonu-klasy">Specjalizacja częściowa szablonu klasy</a></li>
</ul>
</li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#skladowe-jako-szablony">Składowe jako szablony</a></li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#dedukcja-argumentow-szablonu-dla-klas">Dedukcja argumentów szablonu dla klas</a><ul class="nav section-nav flex-column">
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#podpowiedzi-dedukcyjne-deduction-guides">Podpowiedzi dedukcyjne (<em>deduction guides</em>)</a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#niejawne-podpowiedzi-dedukcyjne">Niejawne podpowiedzi dedukcyjne</a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#specjalny-przypadek-dedukcji-argumentow-klasy-szablonowej">Specjalny przypadek dedukcji argumentów klasy szablonowej</a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#agregaty-a-dedukcja-argumentow">Agregaty a dedukcja argumentów</a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#podpowiedzi-dedukcyjne-w-bibliotece-standardowej">Podpowiedzi dedukcyjne w bibliotece standardowej</a><ul class="nav section-nav flex-column">
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#std-pair">std::pair<t></t></a></li>
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#std-tuple-t">std::tuple&lt;T…&gt;</a></li>
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#std-optional">std::optional<t></t></a></li>
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#inteligentne-wskazniki">Inteligentne wskaźniki</a></li>
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#std-function">std::function</a></li>
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#kontenery-i-sekwencje">Kontenery i sekwencje</a></li>
</ul>
</li>
</ul>
</li>
</ul>
            </nav>
        </div>
    </div>
</div>

              
                
<div id="searchbox"></div>
                <article class="bd-article">
                  
  <section id="szablony-klas">
<h1>Szablony klas<a class="headerlink" href="#szablony-klas" title="Link to this heading">#</a></h1>
<p><strong>Szablony klas</strong> (<em>class templates</em>) to mechanizm pozwalający na tworzenie klas, które są parametryzowane. Podobnie jak szablony funkcji, szablony klas są fundamentalnym elementem programowania generycznego w C++.</p>
<p>Szablony klas charakteryzują się następującymi właściwościami:</p>
<ul class="simple">
<li><p><strong>Parametryzacja typu</strong> - klasa może działać z różnymi typami danych określonymi w momencie utworzenia obiektu</p></li>
<li><p><strong>Generowanie kodu na żądanie</strong> - kompilator tworzy kod tylko dla tych funkcji składowych, które rzeczywiście są wywoływane (<em>lazy instantiation</em>)</p></li>
<li><p><strong>Bezpieczeństwo typów</strong> - sprawdzanie typów odbywa się w czasie kompilacji</p></li>
<li><p><strong>Brak narzutu wydajnościowego</strong> - kod jest generowany w czasie kompilacji, więc nie ma narzutu w czasie działania programu</p></li>
</ul>
<p>Szablony klas są szeroko wykorzystywane do:</p>
<ul class="simple">
<li><p><strong>Implementacji kontenerów</strong> - <code class="docutils literal notranslate"><span class="pre">std::vector</span></code>, <code class="docutils literal notranslate"><span class="pre">std::list</span></code>, <code class="docutils literal notranslate"><span class="pre">std::map</span></code> itp.</p></li>
<li><p><strong>Tworzenia smart pointerów</strong> - <code class="docutils literal notranslate"><span class="pre">std::unique_ptr</span></code>, <code class="docutils literal notranslate"><span class="pre">std::shared_ptr</span></code></p></li>
<li><p><strong>Wrapper’ów i adapterów</strong> - <code class="docutils literal notranslate"><span class="pre">std::optional</span></code>, <code class="docutils literal notranslate"><span class="pre">std::variant</span></code>, <code class="docutils literal notranslate"><span class="pre">std::any</span></code></p></li>
<li><p><strong>Metaprogramowania</strong> - obliczenia w czasie kompilacji</p></li>
<li><p><strong>Policy-based design</strong> - elastyczne konfigurowanie zachowania klas</p></li>
</ul>
<section id="podstawowa-skladnia">
<h2>Podstawowa składnia<a class="headerlink" href="#podstawowa-skladnia" title="Link to this heading">#</a></h2>
<section id="definicja-szablonu-klasy">
<h3>Definicja szablonu klasy<a class="headerlink" href="#definicja-szablonu-klasy" title="Link to this heading">#</a></h3>
<p>Szablon klasy definiujemy poprzedzając definicję klasy deklaracją <code class="docutils literal notranslate"><span class="pre">template</span></code> z listą parametrów:</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="k">template</span><span class="w"> </span><span class="o">&lt;</span><span class="k">typename</span><span class="w"> </span><span class="nc">T</span><span class="o">&gt;</span>
<span class="k">class</span><span class="w"> </span><span class="nc">Vector</span><span class="w"> </span>
<span class="p">{</span>
<span class="w">    </span><span class="kt">size_t</span><span class="w"> </span><span class="n">size_</span><span class="p">;</span><span class="w"> </span>
<span class="w">    </span><span class="n">T</span><span class="o">*</span><span class="w"> </span><span class="n">items_</span><span class="p">;</span>
<span class="w">    </span>
<span class="k">public</span><span class="o">:</span><span class="w"> </span>
<span class="w">    </span><span class="k">explicit</span><span class="w"> </span><span class="n">Vector</span><span class="p">(</span><span class="kt">size_t</span><span class="w"> </span><span class="n">size</span><span class="p">);</span>
<span class="w">    </span><span class="o">~</span><span class="n">Vector</span><span class="p">()</span><span class="w"> </span><span class="k">noexcept</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="k">delete</span><span class="w"> </span><span class="p">[]</span><span class="w"> </span><span class="n">items_</span><span class="p">;</span><span class="w"> </span><span class="p">}</span>
<span class="w">    </span>
<span class="w">    </span><span class="c1">// Operacje kopiowania</span>
<span class="w">    </span><span class="n">Vector</span><span class="p">(</span><span class="k">const</span><span class="w"> </span><span class="n">Vector</span><span class="o">&amp;</span><span class="w"> </span><span class="n">other</span><span class="p">);</span>
<span class="w">    </span><span class="n">Vector</span><span class="o">&amp;</span><span class="w"> </span><span class="k">operator</span><span class="o">=</span><span class="p">(</span><span class="k">const</span><span class="w"> </span><span class="n">Vector</span><span class="o">&amp;</span><span class="w"> </span><span class="n">other</span><span class="p">);</span>
<span class="w">    </span>
<span class="w">    </span><span class="c1">// Dostęp do elementów</span>
<span class="w">    </span><span class="k">const</span><span class="w"> </span><span class="n">T</span><span class="o">&amp;</span><span class="w"> </span><span class="k">operator</span><span class="p">[](</span><span class="kt">size_t</span><span class="w"> </span><span class="n">index</span><span class="p">)</span><span class="w"> </span><span class="k">const</span>
<span class="w">    </span><span class="p">{</span>
<span class="w">         </span><span class="k">return</span><span class="w"> </span><span class="n">items_</span><span class="p">[</span><span class="n">index</span><span class="p">];</span>
<span class="w">    </span><span class="p">}</span>

<span class="w">    </span><span class="n">T</span><span class="o">&amp;</span><span class="w"> </span><span class="k">operator</span><span class="p">[](</span><span class="kt">size_t</span><span class="w"> </span><span class="n">index</span><span class="p">)</span>
<span class="w">    </span><span class="p">{</span>
<span class="w">         </span><span class="k">return</span><span class="w"> </span><span class="n">items_</span><span class="p">[</span><span class="n">index</span><span class="p">];</span>
<span class="w">    </span><span class="p">}</span>

<span class="w">    </span><span class="k">const</span><span class="w"> </span><span class="n">T</span><span class="o">&amp;</span><span class="w"> </span><span class="n">at</span><span class="p">(</span><span class="kt">size_t</span><span class="w"> </span><span class="n">index</span><span class="p">)</span><span class="w"> </span><span class="k">const</span><span class="p">;</span>
<span class="w">    </span><span class="n">T</span><span class="o">&amp;</span><span class="w"> </span><span class="nf">at</span><span class="p">(</span><span class="kt">size_t</span><span class="w"> </span><span class="n">index</span><span class="p">);</span>
<span class="w">    </span>
<span class="w">    </span><span class="kt">size_t</span><span class="w"> </span><span class="nf">size</span><span class="p">()</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="k">noexcept</span>
<span class="w">    </span><span class="p">{</span>
<span class="w">        </span><span class="k">return</span><span class="w"> </span><span class="n">size_</span><span class="p">;</span>
<span class="w">    </span><span class="p">}</span>

<span class="w">    </span><span class="kt">bool</span><span class="w"> </span><span class="nf">empty</span><span class="p">()</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="k">noexcept</span>
<span class="w">    </span><span class="p">{</span>
<span class="w">        </span><span class="k">return</span><span class="w"> </span><span class="n">size_</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span>
<span class="w">    </span><span class="p">}</span>

<span class="w">    </span><span class="kt">void</span><span class="w"> </span><span class="nf">swap</span><span class="p">(</span><span class="n">Vector</span><span class="o">&amp;</span><span class="w"> </span><span class="n">other</span><span class="p">)</span><span class="w"> </span><span class="k">noexcept</span>
<span class="w">    </span><span class="p">{</span>
<span class="w">        </span><span class="n">std</span><span class="o">::</span><span class="n">swap</span><span class="p">(</span><span class="n">size_</span><span class="p">,</span><span class="w"> </span><span class="n">other</span><span class="p">.</span><span class="n">size_</span><span class="p">);</span>
<span class="w">        </span><span class="n">std</span><span class="o">::</span><span class="n">swap</span><span class="p">(</span><span class="n">items_</span><span class="p">,</span><span class="w"> </span><span class="n">other</span><span class="p">.</span><span class="n">items_</span><span class="p">);</span>
<span class="w">    </span><span class="p">}</span>
<span class="w">    </span>
<span class="w">    </span><span class="c1">// Iteratory (uproszczone)</span>
<span class="w">    </span><span class="n">T</span><span class="o">*</span><span class="w"> </span><span class="nf">begin</span><span class="p">()</span><span class="w"> </span><span class="k">noexcept</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="k">return</span><span class="w"> </span><span class="n">items_</span><span class="p">;</span><span class="w"> </span><span class="p">}</span>
<span class="w">    </span><span class="n">T</span><span class="o">*</span><span class="w"> </span><span class="nf">end</span><span class="p">()</span><span class="w"> </span><span class="k">noexcept</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="k">return</span><span class="w"> </span><span class="n">items_</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">size_</span><span class="p">;</span><span class="w"> </span><span class="p">}</span>
<span class="w">    </span><span class="k">const</span><span class="w"> </span><span class="n">T</span><span class="o">*</span><span class="w"> </span><span class="nf">begin</span><span class="p">()</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="k">noexcept</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="k">return</span><span class="w"> </span><span class="n">items_</span><span class="p">;</span><span class="w"> </span><span class="p">}</span>
<span class="w">    </span><span class="k">const</span><span class="w"> </span><span class="n">T</span><span class="o">*</span><span class="w"> </span><span class="nf">end</span><span class="p">()</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="k">noexcept</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="k">return</span><span class="w"> </span><span class="n">items_</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">size_</span><span class="p">;</span><span class="w"> </span><span class="p">}</span>
<span class="p">};</span>
</pre></div>
</div>
</section>
<section id="implementacja-funkcji-skladowych-poza-cialem-klasy">
<h3>Implementacja funkcji składowych poza ciałem klasy<a class="headerlink" href="#implementacja-funkcji-skladowych-poza-cialem-klasy" title="Link to this heading">#</a></h3>
<p>Definiując funkcję składową szablonu klasy <strong>poza ciałem klasy</strong>, należy:</p>
<ol class="arabic simple">
<li><p>Poprzedzić definicję deklaracją <code class="docutils literal notranslate"><span class="pre">template</span></code> z parametrami</p></li>
<li><p>Użyć pełnej nazwy klasy z parametrami szablonu (<code class="docutils literal notranslate"><span class="pre">Vector&lt;T&gt;</span></code>)</p></li>
<li><p>Zachować spójność parametrów szablonu</p></li>
</ol>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="c1">// Konstruktor</span>
<span class="k">template</span><span class="w"> </span><span class="o">&lt;</span><span class="k">typename</span><span class="w"> </span><span class="nc">T</span><span class="o">&gt;</span>
<span class="n">Vector</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;::</span><span class="n">Vector</span><span class="p">(</span><span class="kt">size_t</span><span class="w"> </span><span class="n">size</span><span class="p">)</span><span class="w"> </span>
<span class="w">    </span><span class="o">:</span><span class="w"> </span><span class="n">size_</span><span class="p">{</span><span class="n">size</span><span class="p">},</span><span class="w"> </span><span class="n">items_</span><span class="p">{</span><span class="k">new</span><span class="w"> </span><span class="n">T</span><span class="p">[</span><span class="n">size</span><span class="p">]}</span>
<span class="p">{</span>
<span class="w">    </span><span class="n">std</span><span class="o">::</span><span class="n">fill_n</span><span class="p">(</span><span class="n">items_</span><span class="p">,</span><span class="w"> </span><span class="n">size_</span><span class="p">,</span><span class="w"> </span><span class="n">T</span><span class="p">{});</span>
<span class="p">}</span>

<span class="c1">// Konstruktor kopiujący</span>
<span class="k">template</span><span class="w"> </span><span class="o">&lt;</span><span class="k">typename</span><span class="w"> </span><span class="nc">T</span><span class="o">&gt;</span>
<span class="n">Vector</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;::</span><span class="n">Vector</span><span class="p">(</span><span class="k">const</span><span class="w"> </span><span class="n">Vector</span><span class="o">&amp;</span><span class="w"> </span><span class="n">other</span><span class="p">)</span>
<span class="w">    </span><span class="o">:</span><span class="w"> </span><span class="n">size_</span><span class="p">{</span><span class="n">other</span><span class="p">.</span><span class="n">size_</span><span class="p">},</span><span class="w"> </span><span class="n">items_</span><span class="p">{</span><span class="k">new</span><span class="w"> </span><span class="n">T</span><span class="p">[</span><span class="n">size_</span><span class="p">]}</span>
<span class="p">{</span>
<span class="w">    </span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="kt">size_t</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">size_</span><span class="p">;</span><span class="w"> </span><span class="o">++</span><span class="n">i</span><span class="p">)</span>
<span class="w">        </span><span class="n">items_</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">other</span><span class="p">.</span><span class="n">items_</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
<span class="p">}</span>

<span class="c1">// Operator przypisania</span>
<span class="k">template</span><span class="w"> </span><span class="o">&lt;</span><span class="k">typename</span><span class="w"> </span><span class="nc">T</span><span class="o">&gt;</span>
<span class="n">Vector</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;&amp;</span><span class="w"> </span><span class="n">Vector</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;::</span><span class="k">operator</span><span class="o">=</span><span class="p">(</span><span class="k">const</span><span class="w"> </span><span class="n">Vector</span><span class="o">&amp;</span><span class="w"> </span><span class="n">other</span><span class="p">)</span>
<span class="p">{</span>
<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="k">this</span><span class="w"> </span><span class="o">!=</span><span class="w"> </span><span class="o">&amp;</span><span class="n">other</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="n">Vector</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span><span class="w"> </span><span class="n">temp</span><span class="p">(</span><span class="n">other</span><span class="p">);</span><span class="w"> </span><span class="c1">// copy-and-swap idiom</span>
<span class="w">        </span><span class="n">swap</span><span class="p">(</span><span class="n">temp</span><span class="p">);</span>
<span class="w">    </span><span class="p">}</span>
<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="o">*</span><span class="k">this</span><span class="p">;</span>
<span class="p">}</span>

<span class="c1">// Metoda at() z sprawdzaniem zakresu</span>
<span class="k">template</span><span class="w"> </span><span class="o">&lt;</span><span class="k">typename</span><span class="w"> </span><span class="nc">T</span><span class="o">&gt;</span>
<span class="n">T</span><span class="o">&amp;</span><span class="w"> </span><span class="n">Vector</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;::</span><span class="n">at</span><span class="p">(</span><span class="kt">size_t</span><span class="w"> </span><span class="n">index</span><span class="p">)</span>
<span class="p">{</span><span class="w">        </span>
<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">index</span><span class="w"> </span><span class="o">&gt;=</span><span class="w"> </span><span class="n">size_</span><span class="p">)</span>
<span class="w">        </span><span class="k">throw</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">out_of_range</span><span class="p">(</span><span class="s">&quot;Vector::at() - index out of range&quot;</span><span class="p">);</span>

<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="n">items_</span><span class="p">[</span><span class="n">index</span><span class="p">];</span>
<span class="p">}</span>

<span class="k">template</span><span class="w"> </span><span class="o">&lt;</span><span class="k">typename</span><span class="w"> </span><span class="nc">T</span><span class="o">&gt;</span>
<span class="k">const</span><span class="w"> </span><span class="n">T</span><span class="o">&amp;</span><span class="w"> </span><span class="n">Vector</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;::</span><span class="n">at</span><span class="p">(</span><span class="kt">size_t</span><span class="w"> </span><span class="n">index</span><span class="p">)</span><span class="w"> </span><span class="k">const</span>
<span class="p">{</span><span class="w">        </span>
<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">index</span><span class="w"> </span><span class="o">&gt;=</span><span class="w"> </span><span class="n">size_</span><span class="p">)</span>
<span class="w">        </span><span class="k">throw</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">out_of_range</span><span class="p">(</span><span class="s">&quot;Vector::at() - index out of range&quot;</span><span class="p">);</span>

<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="n">items_</span><span class="p">[</span><span class="n">index</span><span class="p">];</span>
<span class="p">}</span>
</pre></div>
</div>
</section>
<section id="tworzenie-instancji-szablonu-klasy">
<h3>Tworzenie instancji szablonu klasy<a class="headerlink" href="#tworzenie-instancji-szablonu-klasy" title="Link to this heading">#</a></h3>
<p>Aby utworzyć obiekt na podstawie szablonu klasy, musimy <strong>jawnie określić parametry szablonu</strong> w nawiasach ostrych <code class="docutils literal notranslate"><span class="pre">&lt;&gt;</span></code>:</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="n">Vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span><span class="w"> </span><span class="n">integral_numbers</span><span class="p">(</span><span class="mi">10</span><span class="p">);</span><span class="w"> </span><span class="c1">// Vector przechowujący wartości typu int</span>
<span class="n">Vector</span><span class="o">&lt;</span><span class="kt">double</span><span class="o">&gt;</span><span class="w"> </span><span class="n">real_numbers</span><span class="p">(</span><span class="mi">20</span><span class="p">);</span><span class="w">  </span><span class="c1">// Vector przechowujący wartości typu double</span>
<span class="n">Vector</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="o">&gt;</span><span class="w"> </span><span class="n">words</span><span class="p">(</span><span class="mi">42</span><span class="p">);</span><span class="w">    </span><span class="c1">// Vector przechowujący wartości typu string</span>
</pre></div>
</div>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>W przeciwieństwie do szablonów funkcji, dla szablonów klas (przed C++17) <strong>nie ma automatycznej dedukcji typów</strong>. Musimy zawsze podać jawnie typ, który jest parametrem szablonu.</p>
<p>Od C++17 nie jest to wymagane dla szablonów klas, które wspierają mechanizm CTAD - <em>Class Template Argument Deduction</em>.</p>
</div>
</section>
<section id="przyklad-uzycia">
<h3>Przykład użycia<a class="headerlink" href="#przyklad-uzycia" title="Link to this heading">#</a></h3>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="c1">// Tworzenie wektora liczb całkowitych</span>
<span class="n">Vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span><span class="w"> </span><span class="n">numbers</span><span class="p">(</span><span class="mi">5</span><span class="p">);</span>
<span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="kt">size_t</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">numbers</span><span class="p">.</span><span class="n">size</span><span class="p">();</span><span class="w"> </span><span class="o">++</span><span class="n">i</span><span class="p">)</span>
<span class="w">    </span><span class="n">numbers</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="mi">10</span><span class="p">;</span>

<span class="c1">// Iteracja używając range-based for (dzięki begin/end)</span>
<span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="k">auto</span><span class="w"> </span><span class="n">num</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="n">numbers</span><span class="p">)</span>
<span class="w">    </span><span class="n">std</span><span class="o">::</span><span class="n">cout</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">num</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="s">&quot; &quot;</span><span class="p">;</span><span class="w">  </span><span class="c1">// Wypisze: 0 10 20 30 40</span>

<span class="n">std</span><span class="o">::</span><span class="n">cout</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="s">&quot;</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">;</span>

<span class="c1">// Tworzenie wektora stringów</span>
<span class="n">Vector</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="o">&gt;</span><span class="w"> </span><span class="n">words</span><span class="p">(</span><span class="mi">3</span><span class="p">);</span>
<span class="n">words</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="s">&quot;Hello&quot;</span><span class="p">;</span>
<span class="n">words</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="s">&quot;World&quot;</span><span class="p">;</span>
<span class="n">words</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="s">&quot;!&quot;</span><span class="p">;</span>

<span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="k">const</span><span class="w"> </span><span class="k">auto</span><span class="o">&amp;</span><span class="w"> </span><span class="n">word</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="n">words</span><span class="p">)</span>
<span class="w">    </span><span class="n">std</span><span class="o">::</span><span class="n">cout</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">word</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="s">&quot; &quot;</span><span class="p">;</span><span class="w">  </span><span class="c1">// Wypisze: Hello World !</span>
<span class="n">std</span><span class="o">::</span><span class="n">cout</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="s">&quot;</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">;</span>
</pre></div>
</div>
</section>
</section>
<section id="parametry-szablonow-klas">
<h2>Parametry szablonów klas<a class="headerlink" href="#parametry-szablonow-klas" title="Link to this heading">#</a></h2>
<p>Szablony klas mogą mieć różne rodzaje parametrów, co daje dużą elastyczność w projektowaniu.</p>
<p>Każdy parametr szablonu może być:</p>
<ol class="arabic simple">
<li><p><strong>Parametrem typu</strong> (<code class="docutils literal notranslate"><span class="pre">typename</span></code> lub <code class="docutils literal notranslate"><span class="pre">class</span></code>) - dowolny typ</p></li>
<li><p><strong>Parametrem niebędącym typem</strong> (<em>non-type parameter - NTTP</em>) - stała wartość znana w czasie kompilacji</p></li>
<li><p><strong>Parametrem będącym szablonem</strong> (<em>template template parameter</em>) - szablon jako parametr</p></li>
</ol>
<section id="parametry-typu">
<h3>1. Parametry typu<a class="headerlink" href="#parametry-typu" title="Link to this heading">#</a></h3>
<p>Najpowszechniejszy rodzaj parametrów:</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="k">template</span><span class="w"> </span><span class="o">&lt;</span><span class="k">typename</span><span class="w"> </span><span class="nc">T</span><span class="o">&gt;</span>
<span class="k">class</span><span class="w"> </span><span class="nc">Box</span>
<span class="p">{</span>
<span class="w">    </span><span class="n">T</span><span class="w"> </span><span class="n">value_</span><span class="p">;</span>
<span class="k">public</span><span class="o">:</span>
<span class="w">    </span><span class="k">explicit</span><span class="w"> </span><span class="n">Box</span><span class="p">(</span><span class="n">T</span><span class="w"> </span><span class="n">v</span><span class="p">)</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="n">value_</span><span class="p">(</span><span class="n">v</span><span class="p">)</span><span class="w"> </span><span class="p">{}</span>
<span class="w">    </span><span class="k">const</span><span class="w"> </span><span class="n">T</span><span class="o">&amp;</span><span class="w"> </span><span class="n">get</span><span class="p">()</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="k">return</span><span class="w"> </span><span class="n">value_</span><span class="p">;</span><span class="w"> </span><span class="p">}</span>
<span class="p">};</span>

<span class="c1">// Użycie</span>
<span class="n">Box</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span><span class="w"> </span><span class="n">int_box</span><span class="p">(</span><span class="mi">42</span><span class="p">);</span>
<span class="n">Box</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="o">&gt;</span><span class="w"> </span><span class="n">str_box</span><span class="p">(</span><span class="s">&quot;Hello&quot;</span><span class="p">);</span>
</pre></div>
</div>
<p>Możemy mieć wiele parametrów, które są typami:</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="k">template</span><span class="w"> </span><span class="o">&lt;</span><span class="k">typename</span><span class="w"> </span><span class="nc">Key</span><span class="p">,</span><span class="w"> </span><span class="k">typename</span><span class="w"> </span><span class="nc">Value</span><span class="o">&gt;</span>
<span class="k">class</span><span class="w"> </span><span class="nc">KeyValuePair</span>
<span class="p">{</span>
<span class="w">    </span><span class="n">Key</span><span class="w"> </span><span class="n">key_</span><span class="p">;</span>
<span class="w">    </span><span class="n">Value</span><span class="w"> </span><span class="n">value_</span><span class="p">;</span>
<span class="k">public</span><span class="o">:</span>
<span class="w">    </span><span class="n">KeyValuePair</span><span class="p">(</span><span class="n">Key</span><span class="w"> </span><span class="n">k</span><span class="p">,</span><span class="w"> </span><span class="n">Value</span><span class="w"> </span><span class="n">v</span><span class="p">)</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="n">key_</span><span class="p">(</span><span class="n">k</span><span class="p">),</span><span class="w"> </span><span class="n">value_</span><span class="p">(</span><span class="n">v</span><span class="p">)</span><span class="w"> </span><span class="p">{}</span>
<span class="w">    </span><span class="n">Key</span><span class="w"> </span><span class="n">key</span><span class="p">()</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="k">return</span><span class="w"> </span><span class="n">key_</span><span class="p">;</span><span class="w"> </span><span class="p">}</span>
<span class="w">    </span><span class="n">Value</span><span class="w"> </span><span class="n">value</span><span class="p">()</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="k">return</span><span class="w"> </span><span class="n">value_</span><span class="p">;</span><span class="w"> </span><span class="p">}</span>
<span class="p">};</span>

<span class="c1">// Użycie</span>
<span class="n">KeyValuePair</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="o">&gt;</span><span class="w"> </span><span class="n">pair</span><span class="p">(</span><span class="s">&quot;age&quot;</span><span class="p">,</span><span class="w"> </span><span class="mi">25</span><span class="p">);</span>
</pre></div>
</div>
</section>
<section id="parametry-niebedace-typami-nttp">
<h3>2. Parametry niebędące typami - NTTP<a class="headerlink" href="#parametry-niebedace-typami-nttp" title="Link to this heading">#</a></h3>
<p>Można używać <strong>parametrów nie będących typami</strong>, o ile są to wartości znane na etapie kompilacji:</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="k">template</span><span class="w"> </span><span class="o">&lt;</span><span class="k">typename</span><span class="w"> </span><span class="nc">T</span><span class="p">,</span><span class="w"> </span><span class="kt">size_t</span><span class="w"> </span><span class="n">N</span><span class="o">&gt;</span>
<span class="k">struct</span><span class="w"> </span><span class="nc">Array</span><span class="w"> </span>
<span class="p">{</span>
<span class="w">    </span><span class="k">using</span><span class="w"> </span><span class="n">value_type</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">T</span><span class="p">;</span>
<span class="w">    </span><span class="k">using</span><span class="w"> </span><span class="n">iterator</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">T</span><span class="o">*</span><span class="p">;</span>
<span class="w">    </span><span class="k">using</span><span class="w"> </span><span class="n">const_iterator</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="n">T</span><span class="o">*</span><span class="p">;</span>

<span class="w">    </span><span class="n">T</span><span class="w"> </span><span class="n">items_</span><span class="p">[</span><span class="n">N</span><span class="p">];</span>
<span class="w">    </span>
<span class="w">    </span><span class="k">constexpr</span><span class="w"> </span><span class="kt">size_t</span><span class="w"> </span><span class="nf">size</span><span class="p">()</span><span class="w"> </span><span class="k">const</span>
<span class="w">    </span><span class="p">{</span>
<span class="w">        </span><span class="k">return</span><span class="w"> </span><span class="n">N</span><span class="p">;</span>
<span class="w">    </span><span class="p">}</span>
<span class="w">    </span>
<span class="w">    </span><span class="n">T</span><span class="o">&amp;</span><span class="w"> </span><span class="k">operator</span><span class="p">[](</span><span class="kt">size_t</span><span class="w"> </span><span class="n">index</span><span class="p">)</span>
<span class="w">    </span><span class="p">{</span>
<span class="w">        </span><span class="k">return</span><span class="w"> </span><span class="n">items_</span><span class="p">[</span><span class="n">index</span><span class="p">];</span>
<span class="w">    </span><span class="p">}</span>
<span class="w">    </span>
<span class="w">    </span><span class="k">const</span><span class="w"> </span><span class="n">T</span><span class="o">&amp;</span><span class="w"> </span><span class="k">operator</span><span class="p">[](</span><span class="kt">size_t</span><span class="w"> </span><span class="n">index</span><span class="p">)</span><span class="w"> </span><span class="k">const</span>
<span class="w">    </span><span class="p">{</span>
<span class="w">        </span><span class="k">return</span><span class="w"> </span><span class="n">items_</span><span class="p">[</span><span class="n">index</span><span class="p">];</span>
<span class="w">    </span><span class="p">}</span>

<span class="w">    </span><span class="n">iterator</span><span class="w"> </span><span class="n">begin</span><span class="p">()</span><span class="w"> </span><span class="k">noexcept</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="k">return</span><span class="w"> </span><span class="n">items_</span><span class="p">;</span><span class="w"> </span><span class="p">}</span>
<span class="w">    </span><span class="n">iterator</span><span class="w"> </span><span class="n">end</span><span class="p">()</span><span class="w"> </span><span class="k">noexcept</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="k">return</span><span class="w"> </span><span class="n">items_</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">N</span><span class="p">;</span><span class="w"> </span><span class="p">}</span>
<span class="w">    </span><span class="n">const_iterator</span><span class="w"> </span><span class="n">begin</span><span class="p">()</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="k">noexcept</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="k">return</span><span class="w"> </span><span class="n">items_</span><span class="p">;</span><span class="w"> </span><span class="p">}</span>
<span class="w">    </span><span class="n">const_iterator</span><span class="w"> </span><span class="n">end</span><span class="p">()</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="k">noexcept</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="k">return</span><span class="w"> </span><span class="n">items_</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">N</span><span class="p">;</span><span class="w"> </span><span class="p">}</span>
<span class="p">};</span><span class="w"> </span>

<span class="c1">// Użycie</span>
<span class="n">Array</span><span class="o">&lt;</span><span class="kt">int</span><span class="p">,</span><span class="w"> </span><span class="mi">10</span><span class="o">&gt;</span><span class="w"> </span><span class="n">small_buffer</span><span class="p">;</span>
<span class="n">Array</span><span class="o">&lt;</span><span class="kt">double</span><span class="p">,</span><span class="w"> </span><span class="mi">1024</span><span class="o">&gt;</span><span class="w"> </span><span class="n">large_buffer</span><span class="p">;</span>
<span class="n">Array</span><span class="o">&lt;</span><span class="kt">char</span><span class="p">,</span><span class="w"> </span><span class="mi">256</span><span class="o">&gt;</span><span class="w"> </span><span class="n">char_buffer</span><span class="p">;</span>

<span class="c1">// Rozmiar jest częścią typu!</span>
<span class="k">static_assert</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="n">Array</span><span class="o">&lt;</span><span class="kt">int</span><span class="p">,</span><span class="w"> </span><span class="mi">10</span><span class="o">&gt;</span><span class="p">)</span><span class="w"> </span><span class="o">!=</span><span class="w"> </span><span class="k">sizeof</span><span class="p">(</span><span class="n">Array</span><span class="o">&lt;</span><span class="kt">int</span><span class="p">,</span><span class="w"> </span><span class="mi">20</span><span class="o">&gt;</span><span class="p">));</span>

<span class="c1">// Nie można przypisać tablic różnych rozmiarów</span>
<span class="c1">// Array&lt;int, 10&gt; a;</span>
<span class="c1">// Array&lt;int, 20&gt; b;</span>
<span class="c1">// a = b;  // BŁĄD - różne typy!</span>
</pre></div>
</div>
<section id="dopuszczalne-parametry-nttp">
<h4>Dopuszczalne parametry NTTP<a class="headerlink" href="#dopuszczalne-parametry-nttp" title="Link to this heading">#</a></h4>
<ul class="simple">
<li><p>Typy całkowite (<code class="docutils literal notranslate"><span class="pre">int</span></code>, <code class="docutils literal notranslate"><span class="pre">long</span></code>, <code class="docutils literal notranslate"><span class="pre">size_t</span></code>, etc.)</p></li>
<li><p>Typy wyliczeniowe</p></li>
<li><p>Wskaźniki i referencje do obiektów/funkcji (C++11)</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">std::nullptr_t</span></code> (C++11)</p></li>
<li><p>Wskaźniki do składowych (C++11)</p></li>
<li><p>Typy zmiennoprzecinkowe (C++20)</p></li>
<li><p>Typy strukturalne (C++20)</p></li>
<li><p>Lambdy (C++20)</p></li>
</ul>
</section>
</section>
<section id="szablony-jako-parametry-szablonow">
<h3>3. Szablony jako parametry szablonów<a class="headerlink" href="#szablony-jako-parametry-szablonow" title="Link to this heading">#</a></h3>
<p><strong>Template template parameters</strong> - gdy jako parametr ma być użyty inny szablon, kompilator musi zostać o tym poinformowany. Należy przy tym określić liczbę i rodzaj parametrów szablonu przekazywanego jako argument:</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="k">template</span><span class="w"> </span><span class="o">&lt;</span><span class="k">typename</span><span class="w"> </span><span class="nc">T</span><span class="p">,</span><span class="w"> </span>
<span class="w">          </span><span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span><span class="p">,</span><span class="w"> </span><span class="k">typename</span><span class="o">&gt;</span><span class="w"> </span><span class="k">class</span><span class="w"> </span><span class="nc">Container</span><span class="p">,</span><span class="w"> </span><span class="cm">/* template template parameter */</span>
<span class="w">          </span><span class="k">typename</span><span class="w"> </span><span class="nc">TAllocator</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">allocator</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;&gt;</span>
<span class="k">class</span><span class="w"> </span><span class="nc">Stack</span><span class="w"> </span>
<span class="p">{</span>
<span class="k">private</span><span class="o">:</span>
<span class="w">    </span><span class="n">Container</span><span class="o">&lt;</span><span class="n">T</span><span class="p">,</span><span class="w"> </span><span class="n">TAllocator</span><span class="o">&gt;</span><span class="w"> </span><span class="n">items_</span><span class="p">;</span>
<span class="w">    </span>
<span class="k">public</span><span class="o">:</span>
<span class="w">    </span><span class="n">Stack</span><span class="p">()</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">default</span><span class="p">;</span>

<span class="w">    </span><span class="kt">void</span><span class="w"> </span><span class="nf">push</span><span class="p">(</span><span class="k">const</span><span class="w"> </span><span class="n">T</span><span class="o">&amp;</span><span class="w"> </span><span class="n">item</span><span class="p">)</span>
<span class="w">    </span><span class="p">{</span>
<span class="w">        </span><span class="n">items_</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="n">item</span><span class="p">);</span>
<span class="w">    </span><span class="p">}</span>

<span class="w">    </span><span class="kt">void</span><span class="w"> </span><span class="nf">push</span><span class="p">(</span><span class="n">T</span><span class="o">&amp;&amp;</span><span class="w"> </span><span class="n">item</span><span class="p">)</span>
<span class="w">    </span><span class="p">{</span>
<span class="w">        </span><span class="n">items_</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">move</span><span class="p">(</span><span class="n">item</span><span class="p">));</span>
<span class="w">    </span><span class="p">}</span>
<span class="w">    </span>
<span class="w">    </span><span class="kt">void</span><span class="w"> </span><span class="nf">pop</span><span class="p">()</span>
<span class="w">    </span><span class="p">{</span>
<span class="w">        </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">items_</span><span class="p">.</span><span class="n">empty</span><span class="p">())</span>
<span class="w">            </span><span class="k">throw</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">underflow_error</span><span class="p">(</span><span class="s">&quot;Stack is empty&quot;</span><span class="p">);</span>
<span class="w">        </span>
<span class="w">        </span><span class="n">items_</span><span class="p">.</span><span class="n">pop_back</span><span class="p">();</span>
<span class="w">    </span><span class="p">}</span>
<span class="w">    </span>
<span class="w">    </span><span class="n">T</span><span class="o">&amp;</span><span class="w"> </span><span class="nf">top</span><span class="p">()</span>
<span class="w">    </span><span class="p">{</span>
<span class="w">        </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">items_</span><span class="p">.</span><span class="n">empty</span><span class="p">())</span>
<span class="w">            </span><span class="k">throw</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">underflow_error</span><span class="p">(</span><span class="s">&quot;Stack is empty&quot;</span><span class="p">);</span>

<span class="w">        </span><span class="k">return</span><span class="w"> </span><span class="n">items_</span><span class="p">.</span><span class="n">back</span><span class="p">();</span>
<span class="w">    </span><span class="p">}</span>
<span class="w">    </span>
<span class="w">    </span><span class="k">const</span><span class="w"> </span><span class="n">T</span><span class="o">&amp;</span><span class="w"> </span><span class="nf">top</span><span class="p">()</span><span class="w"> </span><span class="k">const</span>
<span class="w">    </span><span class="p">{</span>
<span class="w">        </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">items_</span><span class="p">.</span><span class="n">empty</span><span class="p">())</span>
<span class="w">            </span><span class="k">throw</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">underflow_error</span><span class="p">(</span><span class="s">&quot;Stack is empty&quot;</span><span class="p">);</span>
<span class="w">        </span>
<span class="w">        </span><span class="k">return</span><span class="w"> </span><span class="n">items_</span><span class="p">.</span><span class="n">back</span><span class="p">();</span>
<span class="w">    </span><span class="p">}</span>
<span class="w">    </span>
<span class="w">    </span><span class="kt">bool</span><span class="w"> </span><span class="nf">empty</span><span class="p">()</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="k">return</span><span class="w"> </span><span class="n">items_</span><span class="p">.</span><span class="n">empty</span><span class="p">();</span><span class="w"> </span><span class="p">}</span>

<span class="w">    </span><span class="kt">size_t</span><span class="w"> </span><span class="nf">size</span><span class="p">()</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="k">return</span><span class="w"> </span><span class="n">items_</span><span class="p">.</span><span class="n">size</span><span class="p">();</span><span class="w"> </span><span class="p">}</span>
<span class="w">    </span>
<span class="k">private</span><span class="o">:</span>
<span class="w">    </span><span class="n">Container</span><span class="w"> </span><span class="n">items_</span><span class="p">;</span>
<span class="p">};</span>

<span class="c1">// Użycie - podajemy szablon kontenera, nie konkretny typ</span>
<span class="n">Stack</span><span class="o">&lt;</span><span class="kt">int</span><span class="p">,</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&gt;</span><span class="w"> </span><span class="n">vec_stack</span><span class="p">;</span>
<span class="n">Stack</span><span class="o">&lt;</span><span class="kt">int</span><span class="p">,</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">deque</span><span class="o">&gt;</span><span class="w"> </span><span class="n">deque_stack</span><span class="p">;</span>
<span class="n">Stack</span><span class="o">&lt;</span><span class="kt">int</span><span class="p">,</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">list</span><span class="o">&gt;</span><span class="w"> </span><span class="n">list_stack</span><span class="p">;</span>
</pre></div>
</div>
</section>
<section id="parametry-domyslne">
<h3>Parametry domyślne<a class="headerlink" href="#parametry-domyslne" title="Link to this heading">#</a></h3>
<p>Parametrom szablonu klasy można przypisać <strong>argumenty domyślne</strong> (od C++11 możliwe również dla szablonów funkcji):</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="c1">// Domyślny rozmiar tablicy</span>
<span class="k">template</span><span class="w"> </span><span class="o">&lt;</span><span class="k">typename</span><span class="w"> </span><span class="nc">T</span><span class="p">,</span><span class="w"> </span><span class="kt">size_t</span><span class="w"> </span><span class="n">N</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">1024</span><span class="o">&gt;</span>
<span class="k">struct</span><span class="w"> </span><span class="nc">Array</span><span class="w"> </span>
<span class="p">{</span>
<span class="w">    </span><span class="c1">//...</span>
<span class="p">};</span><span class="w"> </span>

<span class="c1">// Użycie z domyślnym rozmiarem</span>
<span class="n">Array</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span><span class="w"> </span><span class="n">default_buffer</span><span class="p">;</span><span class="w">      </span><span class="c1">// Array&lt;int, 1024&gt;</span>
<span class="n">Array</span><span class="o">&lt;</span><span class="kt">int</span><span class="p">,</span><span class="w"> </span><span class="mi">512</span><span class="o">&gt;</span><span class="w"> </span><span class="n">small_buffer</span><span class="p">;</span><span class="w">   </span><span class="c1">// Array&lt;int, 512&gt;</span>
<span class="n">Array</span><span class="o">&lt;</span><span class="kt">double</span><span class="o">&gt;</span><span class="w"> </span><span class="n">double_buffer</span><span class="p">;</span><span class="w">    </span><span class="c1">// Array&lt;double, 1024&gt;</span>
</pre></div>
</div>
<p>Często jako parametr szablonu klasy podaje się kontener (np. <code class="docutils literal notranslate"><span class="pre">std::vector</span></code>, <code class="docutils literal notranslate"><span class="pre">std::list</span></code>, etc.) lub komparator (np. <code class="docutils literal notranslate"><span class="pre">std::less</span></code>, <code class="docutils literal notranslate"><span class="pre">std::greater</span></code>).</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="k">template</span><span class="w"> </span><span class="o">&lt;</span><span class="k">typename</span><span class="w"> </span><span class="nc">T</span><span class="p">,</span><span class="w"> </span><span class="k">typename</span><span class="w"> </span><span class="nc">Compare</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">less</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span><span class="p">,</span><span class="w"> </span><span class="k">typename</span><span class="w"> </span><span class="nc">Container</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;&gt;</span>
<span class="k">class</span><span class="w"> </span><span class="nc">PriorityQueue</span>
<span class="p">{</span>
<span class="w">    </span><span class="n">Container</span><span class="w"> </span><span class="n">items_</span><span class="p">;</span>
<span class="w">    </span><span class="p">[[</span><span class="n">no_unique_address</span><span class="p">]]</span><span class="w"> </span><span class="n">Compare</span><span class="w"> </span><span class="n">comp_</span><span class="p">;</span><span class="w">    </span>
<span class="w">    </span>
<span class="k">public</span><span class="o">:</span>
<span class="w">    </span><span class="n">PriorityQueue</span><span class="p">()</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="n">items_</span><span class="p">(),</span><span class="w"> </span><span class="n">comp_</span><span class="p">()</span><span class="w"> </span><span class="p">{}</span>

<span class="w">    </span><span class="kt">void</span><span class="w"> </span><span class="n">insert</span><span class="p">(</span><span class="k">const</span><span class="w"> </span><span class="n">T</span><span class="o">&amp;</span><span class="w"> </span><span class="n">item</span><span class="p">)</span>
<span class="w">    </span><span class="p">{</span>
<span class="w">        </span><span class="k">auto</span><span class="w"> </span><span class="n">it</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">lower_bound</span><span class="p">(</span><span class="n">items_</span><span class="p">.</span><span class="n">begin</span><span class="p">(),</span><span class="w"> </span><span class="n">items_</span><span class="p">.</span><span class="n">end</span><span class="p">(),</span><span class="w"> </span><span class="n">item</span><span class="p">,</span><span class="w"> </span><span class="n">comp_</span><span class="p">);</span>
<span class="w">        </span><span class="n">items_</span><span class="p">.</span><span class="n">insert</span><span class="p">(</span><span class="n">it</span><span class="p">,</span><span class="w"> </span><span class="n">item</span><span class="p">);</span>
<span class="w">    </span><span class="p">}</span>
<span class="w">    </span>
<span class="w">    </span><span class="k">const</span><span class="w"> </span><span class="n">T</span><span class="o">&amp;</span><span class="w"> </span><span class="n">front</span><span class="p">()</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="k">return</span><span class="w"> </span><span class="n">items_</span><span class="p">.</span><span class="n">front</span><span class="p">();</span><span class="w"> </span><span class="p">}</span>

<span class="w">    </span><span class="c1">//...</span>
<span class="p">};</span>

<span class="c1">// Użycie z domyślnym komparatorem</span>
<span class="n">PriorityQueue</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span><span class="w"> </span><span class="n">numbers_ascending</span><span class="p">;</span><span class="w">  </span><span class="c1">// std::less&lt;int&gt;</span>

<span class="c1">// Użycie z własnym komparatorem</span>
<span class="n">PriorityQueue</span><span class="o">&lt;</span><span class="kt">int</span><span class="p">,</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">greater</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;&gt;</span><span class="w"> </span><span class="n">numbers_descending</span><span class="p">;</span>

<span class="c1">// Użycie z własnym komparatorem i kontenerem</span>
<span class="n">PriorityQueue</span><span class="o">&lt;</span><span class="kt">int</span><span class="p">,</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">greater</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span><span class="p">,</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">deque</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;&gt;</span><span class="w"> </span><span class="n">numbers_descending_deque</span><span class="p">;</span><span class="w">    </span>
</pre></div>
</div>
</section>
</section>
<section id="specjalizacja-szablonow-klas">
<h2>Specjalizacja szablonów klas<a class="headerlink" href="#specjalizacja-szablonow-klas" title="Link to this heading">#</a></h2>
<p>Specjalizacja szablonów klas:</p>
<ul class="simple">
<li><p>polega na osobnej implementacji szablonów dla wybranych typów argumentów.</p></li>
<li><p>umożliwia optymalizację implementacji dla wybranych typów lub uniknięcie niepożądanego zachowania na skutek utworzenia instancji szablonu dla określonego typu.</p></li>
</ul>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="k">template</span><span class="w"> </span><span class="o">&lt;</span><span class="k">typename</span><span class="w"> </span><span class="nc">T</span><span class="o">&gt;</span><span class="w"> </span><span class="k">class</span><span class="w"> </span><span class="nc">Pair</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="cm">/* ... */</span><span class="w"> </span><span class="p">};</span><span class="w">     </span><span class="c1">// szablon ogólny</span>
<span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span><span class="w"> </span><span class="nc">T</span><span class="o">&gt;</span><span class="w"> </span><span class="k">class</span><span class="w"> </span><span class="nc">Pair</span><span class="o">&lt;</span><span class="n">T</span><span class="o">*&gt;</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="cm">/* ... */</span><span class="w"> </span><span class="p">};</span><span class="w">  </span><span class="c1">// częściowa specjalizacja</span>
<span class="k">template</span><span class="o">&lt;&gt;</span><span class="w"> </span><span class="k">class</span><span class="w"> </span><span class="nc">Pair</span><span class="o">&lt;</span><span class="k">const</span><span class="w"> </span><span class="kt">char</span><span class="o">*&gt;</span><span class="p">{</span><span class="w"> </span><span class="cm">/* ... */</span><span class="w"> </span><span class="p">};</span><span class="w">    </span><span class="c1">// pełna specjalizacja</span>
</pre></div>
</div>
<section id="pelna-specjalizacja-szablonu-klasy">
<h3>Pełna specjalizacja szablonu klasy<a class="headerlink" href="#pelna-specjalizacja-szablonu-klasy" title="Link to this heading">#</a></h3>
<p>Deklaracja pełnej specjalizacji wymaga podania:</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="k">template</span><span class="w"> </span><span class="o">&lt;&gt;</span>
<span class="k">class</span><span class="w"> </span><span class="nc">Vector</span><span class="o">&lt;</span><span class="kt">bool</span><span class="o">&gt;</span>
<span class="p">{</span>
<span class="w">    </span><span class="c1">//...</span>
<span class="p">};</span>
</pre></div>
</div>
<p>Jeśli specjalizujemy szablon klasy, to musimy zapewnić wyspecjalizowaną implementację dla wszystkich funkcji składowych.</p>
<p>Możliwe jest natomiast rozszerzenie interfejsu klasy o dodatkowe składowe (np. <code class="docutils literal notranslate"><span class="pre">std::vector&lt;bool&gt;</span></code> definiuje dodatkowe metody <code class="docutils literal notranslate"><span class="pre">flip()</span></code>)</p>
</section>
<section id="specjalizacja-czesciowa-szablonu-klasy">
<h3>Specjalizacja częściowa szablonu klasy<a class="headerlink" href="#specjalizacja-czesciowa-szablonu-klasy" title="Link to this heading">#</a></h3>
<p>Dla szablonów klas (w odróżnieniu od szablonów funkcji) możliwe jest tworzenie częściowych specjalizacji szablonów.</p>
<p>Dla szablonu klasy:</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="k">template</span><span class="w"> </span><span class="o">&lt;</span><span class="k">class</span><span class="w"> </span><span class="nc">T1</span><span class="p">,</span><span class="w"> </span><span class="k">class</span><span class="w"> </span><span class="nc">T2</span><span class="o">&gt;</span>
<span class="k">class</span><span class="w"> </span><span class="nc">MyClass</span><span class="w"> </span>
<span class="p">{</span>
<span class="w">  </span><span class="c1">//...</span>
<span class="p">};</span>
</pre></div>
</div>
<p>możemy utworzyć następujące specjalizacje częściowe:</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="k">template</span><span class="w"> </span><span class="o">&lt;</span><span class="k">typename</span><span class="w"> </span><span class="nc">T</span><span class="o">&gt;</span>
<span class="k">class</span><span class="w"> </span><span class="nc">MyClass</span><span class="o">&lt;</span><span class="n">T</span><span class="p">,</span><span class="w"> </span><span class="n">T</span><span class="o">&gt;</span><span class="w"> </span>
<span class="p">{</span><span class="w"> </span>
<span class="w">  </span><span class="c1">// specjalizacja częściowa: drugim typem jest T</span>
<span class="p">};</span>
</pre></div>
</div>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="k">template</span><span class="w"> </span><span class="o">&lt;</span><span class="k">typename</span><span class="w"> </span><span class="nc">T</span><span class="o">&gt;</span>
<span class="k">class</span><span class="w"> </span><span class="nc">MyClass</span><span class="o">&lt;</span><span class="n">T</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="o">&gt;</span><span class="w"> </span>
<span class="p">{</span>
<span class="w">    </span><span class="c1">// specjalizacja częściowa: drugim typem jest int </span>
<span class="p">};</span>
</pre></div>
</div>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="k">template</span><span class="w"> </span><span class="o">&lt;</span><span class="k">typename</span><span class="w"> </span><span class="nc">T1</span><span class="p">,</span><span class="w"> </span><span class="k">typename</span><span class="w"> </span><span class="nc">T2</span><span class="o">&gt;</span>
<span class="k">class</span><span class="w"> </span><span class="nc">MyClass</span><span class="o">&lt;</span><span class="n">T1</span><span class="o">*</span><span class="p">,</span><span class="w"> </span><span class="n">T2</span><span class="o">*&gt;</span><span class="w"> </span>
<span class="p">{</span>
<span class="w">    </span><span class="c1">// oba parametry są wskaźnikami </span>
<span class="p">};</span>
</pre></div>
</div>
<p>Poniższe przykłady pokazują, które wersje szablonu klasy zostaną utworzone:</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="n">MyClass</span><span class="o">&lt;</span><span class="kt">int</span><span class="p">,</span><span class="w"> </span><span class="kt">float</span><span class="o">&gt;</span><span class="w"> </span><span class="n">mif</span><span class="p">;</span><span class="w">      </span><span class="c1">// uses MyClass&lt;T1,T2&gt;</span>
<span class="n">MyClass</span><span class="o">&lt;</span><span class="kt">float</span><span class="p">,</span><span class="w"> </span><span class="kt">float</span><span class="o">&gt;</span><span class="w"> </span><span class="n">mff</span><span class="p">;</span><span class="w">    </span><span class="c1">// uses MyClass&lt;T,T&gt;</span>
<span class="n">MyClass</span><span class="o">&lt;</span><span class="kt">float</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="o">&gt;</span><span class="w"> </span><span class="n">mfi</span><span class="p">;</span><span class="w">      </span><span class="c1">// uses MyClass&lt;T,int&gt;</span>
<span class="n">MyClass</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">*</span><span class="p">,</span><span class="w"> </span><span class="kt">float</span><span class="o">*&gt;</span><span class="w"> </span><span class="n">mp</span><span class="p">;</span><span class="w">     </span><span class="c1">// uses MyClass&lt;T1*,T2*&gt;</span>
</pre></div>
</div>
<p>W przypadku, gdy więcej niż jedna specjalizacja pasuje wystarczająco dobrze zgłaszany jest błąd dwuznaczności:</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="n">MyClass</span><span class="o">&lt;</span><span class="kt">int</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="o">&gt;</span><span class="w"> </span><span class="n">me1</span><span class="p">;</span><span class="w"> </span><span class="c1">// ERROR: matches MyClass&lt;T, T&gt; &amp; MyClass&lt;T, int&gt;</span>

<span class="n">MyClass</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">*</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="o">*&gt;</span><span class="w"> </span><span class="n">me2</span><span class="p">;</span><span class="w"> </span><span class="c1">// ERROR: matches MyClass&lt;T, T&gt; &amp; MyClass&lt;T1*, T1*&gt;</span>
</pre></div>
</div>
</section>
</section>
<section id="skladowe-jako-szablony">
<h2>Składowe jako szablony<a class="headerlink" href="#skladowe-jako-szablony" title="Link to this heading">#</a></h2>
<p>Składowe klas mogą być szablonami. Dotyczy to:</p>
<ul class="simple">
<li><p>wewnętrznych klas pomocniczych,</p></li>
<li><p>funkcji składowych.</p></li>
</ul>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="k">template</span><span class="w"> </span><span class="o">&lt;</span><span class="k">typename</span><span class="w"> </span><span class="nc">T</span><span class="o">&gt;</span>
<span class="k">class</span><span class="w"> </span><span class="nc">Stack</span><span class="w"> </span>
<span class="p">{</span>
<span class="w">    </span><span class="n">std</span><span class="o">::</span><span class="n">deque</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span><span class="w"> </span><span class="n">items_</span><span class="p">;</span>
<span class="k">public</span><span class="o">:</span>
<span class="w">    </span><span class="kt">void</span><span class="w"> </span><span class="n">push</span><span class="p">(</span><span class="k">const</span><span class="w"> </span><span class="n">T</span><span class="o">&amp;</span><span class="p">);</span>
<span class="w">    </span><span class="kt">void</span><span class="w"> </span><span class="nf">pop</span><span class="p">();</span>
<span class="w">    </span><span class="c1">//...</span>
<span class="w">    </span><span class="c1">// przypisanie stosu o elementach typu U</span>
<span class="w">    </span><span class="k">template</span><span class="w"> </span><span class="o">&lt;</span><span class="k">typename</span><span class="w"> </span><span class="nc">U</span><span class="o">&gt;</span>
<span class="w">    </span><span class="n">Stack</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;&amp;</span><span class="w"> </span><span class="k">operator</span><span class="o">=</span><span class="p">(</span><span class="k">const</span><span class="w"> </span><span class="n">Stack</span><span class="o">&lt;</span><span class="n">U</span><span class="o">&gt;&amp;</span><span class="p">);</span>
<span class="p">};</span><span class="w"> </span>

<span class="k">template</span><span class="w"> </span><span class="o">&lt;</span><span class="k">typename</span><span class="w"> </span><span class="nc">T</span><span class="o">&gt;</span>
<span class="w">    </span><span class="k">template</span><span class="w"> </span><span class="o">&lt;</span><span class="k">typename</span><span class="w"> </span><span class="nc">U</span><span class="o">&gt;</span>
<span class="n">Stack</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;&amp;</span><span class="w"> </span><span class="n">Stack</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;::</span><span class="k">operator</span><span class="o">=</span><span class="p">(</span><span class="k">const</span><span class="w"> </span><span class="n">Stack</span><span class="o">&lt;</span><span class="n">U</span><span class="o">&gt;&amp;</span><span class="w"> </span><span class="n">source</span><span class="p">)</span>
<span class="p">{</span>
<span class="w">    </span><span class="c1">//...</span>
<span class="p">}</span>
</pre></div>
</div>
</section>
<section id="dedukcja-argumentow-szablonu-dla-klas">
<h2>Dedukcja argumentów szablonu dla klas<a class="headerlink" href="#dedukcja-argumentow-szablonu-dla-klas" title="Link to this heading">#</a></h2>
<p>C++17 wprowadza mechanizm dedukcji argumentów szablonu klasy (<em>Class Template Argument Deduction</em>).
Typy parametrów szablonu klasy mogą być dedukowane na podstawie argumentów przekazanych do konstruktora tworzonego obiektu.</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="k">template</span><span class="w"> </span><span class="o">&lt;</span><span class="k">typename</span><span class="w"> </span><span class="nc">T</span><span class="o">&gt;</span>
<span class="k">class</span><span class="w"> </span><span class="nc">complex</span>
<span class="p">{</span>
<span class="w">    </span><span class="n">T</span><span class="w"> </span><span class="n">re_</span><span class="p">,</span><span class="w"> </span><span class="n">img_</span><span class="p">;</span>
<span class="k">public</span><span class="o">:</span>
<span class="w">    </span><span class="n">complex</span><span class="p">(</span><span class="n">T</span><span class="w"> </span><span class="n">re</span><span class="p">,</span><span class="w"> </span><span class="n">T</span><span class="w"> </span><span class="n">img</span><span class="p">)</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="n">re_</span><span class="p">{</span><span class="n">re</span><span class="p">},</span><span class="w"> </span><span class="n">img_</span><span class="p">{</span><span class="n">img</span><span class="p">}</span>
<span class="w">    </span><span class="p">{}</span>
<span class="p">};</span>

<span class="k">auto</span><span class="w"> </span><span class="n">c1</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">complex</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span><span class="p">{</span><span class="mi">5</span><span class="p">,</span><span class="w"> </span><span class="mi">2</span><span class="p">};</span><span class="w"> </span><span class="c1">// OK - all versions of C++ standard</span>

<span class="k">auto</span><span class="w"> </span><span class="n">c2</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">complex</span><span class="p">{</span><span class="mi">5</span><span class="p">,</span><span class="w"> </span><span class="mi">3</span><span class="p">};</span><span class="w"> </span><span class="c1">// OK since C++17 - compiler deduces complex&lt;int&gt;</span>

<span class="k">auto</span><span class="w"> </span><span class="n">c3</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">complex</span><span class="p">(</span><span class="mf">5.1</span><span class="p">,</span><span class="w"> </span><span class="mf">6.5</span><span class="p">);</span><span class="w"> </span><span class="c1">// OK in C++17 - compiler deduces complex&lt;double&gt;</span>

<span class="k">auto</span><span class="w"> </span><span class="n">c4</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">complex</span><span class="p">{</span><span class="mi">5</span><span class="p">,</span><span class="w"> </span><span class="mf">4.1</span><span class="p">};</span><span class="w"> </span><span class="c1">// ERROR - args don&#39;t have the same type</span>
<span class="k">auto</span><span class="w"> </span><span class="n">c5</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">complex</span><span class="p">(</span><span class="mi">5</span><span class="p">,</span><span class="w"> </span><span class="mf">4.1</span><span class="p">);</span><span class="w"> </span><span class="c1">// ERROR - args don&#39;t have the same type</span>
</pre></div>
</div>
<div class="admonition warning">
<p class="admonition-title">Warning</p>
<p>Nie można częściowo dedukować argumentów szablonu klasy. Należy wyspecifikować lub wydedukować wszystkie parametry z wyjątkiem parametrów domyślnych.</p>
</div>
<p>Praktyczny przykład dedukcji argumentów szablonu klasy:</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="n">std</span><span class="o">::</span><span class="n">mutex</span><span class="w"> </span><span class="n">mtx</span><span class="p">;</span>

<span class="n">std</span><span class="o">::</span><span class="n">lock_guard</span><span class="w"> </span><span class="n">lk</span><span class="p">{</span><span class="n">mtx</span><span class="p">};</span><span class="w"> </span><span class="c1">// deduces std::lock_guard&lt;std::mutex&gt;</span>
</pre></div>
</div>
<section id="podpowiedzi-dedukcyjne-deduction-guides">
<h3>Podpowiedzi dedukcyjne (<em>deduction guides</em>)<a class="headerlink" href="#podpowiedzi-dedukcyjne-deduction-guides" title="Link to this heading">#</a></h3>
<p>C++17 umożliwia tworzenie podpowiedzi dla kompilatora, jak powinny być dedukowane typy parametrów szablonu klasy na podstawie wywołania odpowiedniego konstruktora.</p>
<p>Daje to możliwość poprawy/modyfikacji domyślnego procesu dedukcji.</p>
<p>Dla szablonu:</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="k">template</span><span class="w"> </span><span class="o">&lt;</span><span class="k">typename</span><span class="w"> </span><span class="nc">T</span><span class="o">&gt;</span>
<span class="k">class</span><span class="w"> </span><span class="nc">S</span>
<span class="p">{</span>
<span class="k">private</span><span class="o">:</span>
<span class="w">    </span><span class="n">T</span><span class="w"> </span><span class="n">value</span><span class="p">;</span>
<span class="k">public</span><span class="o">:</span>
<span class="w">    </span><span class="n">S</span><span class="p">(</span><span class="n">T</span><span class="w"> </span><span class="n">v</span><span class="p">)</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="n">value</span><span class="p">(</span><span class="n">v</span><span class="p">)</span>
<span class="w">    </span><span class="p">{}</span>
<span class="p">};</span>
</pre></div>
</div>
<p>Podpowiedź dedukcyjna musi zostać umieszczona w tym samym zakresie (przestrzeni nazw) i może mieć postać:</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="k">template</span><span class="w"> </span><span class="o">&lt;</span><span class="k">typename</span><span class="w"> </span><span class="nc">T</span><span class="o">&gt;</span><span class="w"> </span><span class="n">S</span><span class="p">(</span><span class="n">T</span><span class="p">)</span><span class="w"> </span><span class="o">-&gt;</span><span class="w"> </span><span class="n">S</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span><span class="p">;</span><span class="w"> </span><span class="c1">// deduction guide</span>
</pre></div>
</div>
<p>gdzie:</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">S&lt;T&gt;</span></code> to tzw. typ zalecany (<em>guided type</em>)</p></li>
<li><p>nazwa podpowiedzi dedukcyjnej musi być niekwalifikowaną nazwą klasy szablonowej zadeklarowanej wcześniej w tym samym zakresie</p></li>
<li><p>typ zalecany podpowiedzi musi odwoływać się do identyfikatora szablonu (<em>template-id</em>), do którego odnosi się podpowiedź</p></li>
</ul>
<p>Użycie podpowiedzi:</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="n">S</span><span class="w"> </span><span class="n">x</span><span class="p">{</span><span class="mi">12</span><span class="p">};</span><span class="w"> </span><span class="c1">// OK -&gt; S&lt;int&gt; x{12};</span>
<span class="n">S</span><span class="w"> </span><span class="nf">y</span><span class="p">(</span><span class="mi">12</span><span class="p">);</span><span class="w"> </span><span class="c1">// OK -&gt; S&lt;int&gt; y(12);</span>
<span class="k">auto</span><span class="w"> </span><span class="n">z</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">S</span><span class="p">{</span><span class="mi">12</span><span class="p">};</span><span class="w"> </span><span class="c1">// OK -&gt; auto z = S&lt;int&gt;{12};</span>
<span class="n">S</span><span class="w"> </span><span class="nf">s1</span><span class="p">(</span><span class="mi">1</span><span class="p">),</span><span class="w"> </span><span class="n">s2</span><span class="p">{</span><span class="mi">2</span><span class="p">};</span><span class="w"> </span><span class="c1">// OK -&gt; S&lt;int&gt; s1(1), s2{2};</span>
<span class="n">S</span><span class="w"> </span><span class="nf">s3</span><span class="p">(</span><span class="mi">42</span><span class="p">),</span><span class="w"> </span><span class="n">s4</span><span class="p">{</span><span class="mf">3.14</span><span class="p">};</span><span class="w"> </span><span class="c1">// ERROR</span>
</pre></div>
</div>
<p>W deklaracji <code class="docutils literal notranslate"><span class="pre">S</span> <span class="pre">x{12};</span></code> specyfikator <code class="docutils literal notranslate"><span class="pre">S</span></code> jest nazywany symbolem zastępczym dla klasy (<em>placeholder class type</em>).</p>
<p>W przypadku użycia symbolu zastępczego dla klasy, nazwa zmiennej musi zostać podana jako następny element składni.
W rezultacie poniższa deklaracja jest błędem składniowym:</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="n">S</span><span class="o">*</span><span class="w"> </span><span class="n">p</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="o">&amp;</span><span class="n">x</span><span class="p">;</span><span class="w"> </span><span class="c1">// ERROR - syntax not permitted</span>
</pre></div>
</div>
<p>Dany szablon klasy może mieć wiele konstruktorów oraz wiele podpowiedzi dedukcyjnych:</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="k">template</span><span class="w"> </span><span class="o">&lt;</span><span class="k">typename</span><span class="w"> </span><span class="nc">T</span><span class="o">&gt;</span>
<span class="k">struct</span><span class="w"> </span><span class="nc">Data</span>
<span class="p">{</span>
<span class="w">    </span><span class="n">T</span><span class="w"> </span><span class="n">value</span><span class="p">;</span>

<span class="w">    </span><span class="k">using</span><span class="w"> </span><span class="n">type1</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">T</span><span class="p">;</span>

<span class="w">    </span><span class="n">Data</span><span class="p">(</span><span class="k">const</span><span class="w"> </span><span class="n">T</span><span class="o">&amp;</span><span class="w"> </span><span class="n">v</span><span class="p">)</span>
<span class="w">        </span><span class="o">:</span><span class="w"> </span><span class="n">value</span><span class="p">(</span><span class="n">v</span><span class="p">)</span>
<span class="w">    </span><span class="p">{</span>
<span class="w">    </span><span class="p">}</span>

<span class="w">    </span><span class="k">template</span><span class="w"> </span><span class="o">&lt;</span><span class="k">typename</span><span class="w"> </span><span class="nc">ItemType</span><span class="o">&gt;</span>
<span class="w">    </span><span class="n">Data</span><span class="p">(</span><span class="n">initializer_list</span><span class="o">&lt;</span><span class="n">ItemType</span><span class="o">&gt;</span><span class="w"> </span><span class="n">il</span><span class="p">)</span>
<span class="w">        </span><span class="o">:</span><span class="w"> </span><span class="n">value</span><span class="p">(</span><span class="n">il</span><span class="p">)</span>
<span class="w">    </span><span class="p">{</span>
<span class="w">    </span><span class="p">}</span>
<span class="p">};</span>

<span class="k">template</span><span class="w"> </span><span class="o">&lt;</span><span class="k">typename</span><span class="w"> </span><span class="nc">T</span><span class="o">&gt;</span>
<span class="n">Data</span><span class="p">(</span><span class="n">T</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">Data</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span><span class="p">;</span>

<span class="k">template</span><span class="w"> </span><span class="o">&lt;</span><span class="k">typename</span><span class="w"> </span><span class="nc">T</span><span class="o">&gt;</span>
<span class="n">Data</span><span class="p">(</span><span class="n">initializer_list</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">Data</span><span class="o">&lt;</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;&gt;</span><span class="p">;</span>

<span class="n">Data</span><span class="p">(</span><span class="k">const</span><span class="w"> </span><span class="kt">char</span><span class="o">*</span><span class="p">)</span><span class="w"> </span><span class="o">-&gt;</span><span class="w"> </span><span class="n">Data</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="o">&gt;</span><span class="p">;</span>

<span class="c1">//...</span>

<span class="n">Data</span><span class="w"> </span><span class="n">d1</span><span class="p">(</span><span class="s">&quot;hello&quot;</span><span class="p">);</span><span class="w"> </span><span class="c1">// OK -&gt; Data&lt;string&gt;</span>

<span class="k">const</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">tab</span><span class="p">[</span><span class="mi">10</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">{</span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="mi">2</span><span class="p">,</span><span class="w"> </span><span class="mi">3</span><span class="p">,</span><span class="w"> </span><span class="mi">4</span><span class="p">};</span>
<span class="n">Data</span><span class="w"> </span><span class="nf">d2</span><span class="p">(</span><span class="n">tab</span><span class="p">);</span><span class="w"> </span><span class="c1">// OK -&gt; Data&lt;const int*&gt;</span>

<span class="n">Data</span><span class="w"> </span><span class="n">d3</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">3</span><span class="p">;</span><span class="w"> </span><span class="c1">// OK -&gt; Data&lt;int&gt;</span>

<span class="n">Data</span><span class="w"> </span><span class="n">d4</span><span class="p">{</span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="mi">2</span><span class="p">,</span><span class="w"> </span><span class="mi">3</span><span class="p">,</span><span class="w"> </span><span class="mi">4</span><span class="p">};</span><span class="w"> </span><span class="c1">// OK -&gt; Data&lt;vector&lt;int&gt;&gt;</span>

<span class="n">Data</span><span class="w"> </span><span class="n">d5</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">{</span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="mi">2</span><span class="p">,</span><span class="w"> </span><span class="mi">3</span><span class="p">,</span><span class="w"> </span><span class="mi">4</span><span class="p">};</span><span class="w"> </span><span class="c1">// OK -&gt; Data&lt;vector&lt;int&gt;&gt;</span>

<span class="n">Data</span><span class="w"> </span><span class="n">d6</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">{</span><span class="mi">1</span><span class="p">};</span><span class="w"> </span><span class="c1">// OK -&gt; Data&lt;vector&lt;int&gt;&gt;</span>

<span class="n">Data</span><span class="w"> </span><span class="nf">d7</span><span class="p">(</span><span class="n">d6</span><span class="p">);</span><span class="w"> </span><span class="c1">// OK - copy by default rule -&gt; Data&lt;vector&lt;int&gt;&gt;</span>

<span class="n">Data</span><span class="w"> </span><span class="n">d8</span><span class="p">{</span><span class="n">d6</span><span class="p">,</span><span class="w"> </span><span class="n">d7</span><span class="p">};</span><span class="w"> </span><span class="c1">// OK -&gt; Data&lt;vector&lt;Data&lt;vector&lt;int&gt;&gt;&gt;&gt;</span>
</pre></div>
</div>
<p>Podpowiedzi dedukcyjne nie są szablonami funkcji - służą jedynie dedukowaniu argumentów szablonu i nie są wywoływane.
W rezultacie nie ma znaczenia czy argumenty w deklaracjach dedukcyjnych są przekazywane przez referencje, czy nie.</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="k">template</span><span class="w"> </span><span class="o">&lt;</span><span class="k">typename</span><span class="w"> </span><span class="nc">T</span><span class="o">&gt;</span><span class="w"> </span>
<span class="k">struct</span><span class="w"> </span><span class="nc">X</span>
<span class="p">{</span>
<span class="w">    </span><span class="c1">//...</span>
<span class="p">};</span>

<span class="k">template</span><span class="w"> </span><span class="o">&lt;</span><span class="k">typename</span><span class="w"> </span><span class="nc">T</span><span class="o">&gt;</span>
<span class="k">struct</span><span class="w"> </span><span class="nc">Y</span>
<span class="p">{</span>
<span class="w">    </span><span class="n">Y</span><span class="p">(</span><span class="k">const</span><span class="w"> </span><span class="n">X</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;&amp;</span><span class="p">);</span>
<span class="w">    </span><span class="n">Y</span><span class="p">(</span><span class="n">X</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;&amp;&amp;</span><span class="p">);</span>
<span class="p">};</span>

<span class="k">template</span><span class="w"> </span><span class="o">&lt;</span><span class="k">typename</span><span class="w"> </span><span class="nc">T</span><span class="o">&gt;</span><span class="w"> </span><span class="n">Y</span><span class="p">(</span><span class="n">X</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span><span class="p">)</span><span class="w"> </span><span class="o">-&gt;</span><span class="w"> </span><span class="n">Y</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span><span class="p">;</span><span class="w"> </span><span class="c1">// deduction guide without references</span>
</pre></div>
</div>
<p>W powyższym przykładzie podpowiedź dedukcyjna nie odpowiada dokładnie sygnaturom konstruktorów przeciążonych. Nie ma to znaczenia, ponieważ jedynym celem podpowiedzi jest umożliwienie dedukcji typu, który jest parametrem szablonu. Dopasowanie wywołania przeciążonego konstruktora odbywa się później.</p>
</section>
<section id="niejawne-podpowiedzi-dedukcyjne">
<h3>Niejawne podpowiedzi dedukcyjne<a class="headerlink" href="#niejawne-podpowiedzi-dedukcyjne" title="Link to this heading">#</a></h3>
<p>Ponieważ często podpowiedź dedukcyjna jest potrzebna dla każdego konstruktora klasy, standard C++17
wprowadza mechanizm <strong>niejawnych podpowiedzi dedukcyjnych</strong> (<em>implicit deduction guides</em>).
Działa on w następujący sposób:</p>
<ul class="simple">
<li><p>Lista parametrów szablonu dla podpowiedzi zawiera listę parametrów z szablonu klasy</p>
<ul>
<li><p>w przypadku szablonowego konstruktora klasy kolejnym elementem jest lista parametrów szablonu konstruktora klasy</p></li>
</ul>
</li>
<li><p>Parametry “funkcyjne” podpowiedzi są kopiowane z konstruktora lub konstruktora szablonowego</p></li>
<li><p>Zalecany typ w podpowiedzi jest nazwą szablonu z argumentami, które są parametrami szablonu wziętymi
z klasy szablonowej</p></li>
</ul>
<p>Dla klasy szablonowej rozważanej powyżej:</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="k">template</span><span class="w"> </span><span class="o">&lt;</span><span class="k">typename</span><span class="w"> </span><span class="nc">T</span><span class="o">&gt;</span>
<span class="k">class</span><span class="w"> </span><span class="nc">S</span>
<span class="p">{</span>
<span class="k">private</span><span class="o">:</span>
<span class="w">    </span><span class="n">T</span><span class="w"> </span><span class="n">value</span><span class="p">;</span>
<span class="k">public</span><span class="o">:</span>
<span class="w">    </span><span class="n">S</span><span class="p">(</span><span class="n">T</span><span class="w"> </span><span class="n">v</span><span class="p">)</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="n">value</span><span class="p">(</span><span class="n">v</span><span class="p">)</span>
<span class="w">    </span><span class="p">{}</span>
<span class="p">};</span>
</pre></div>
</div>
<p>niejawna podpowiedź dedukcyjna będzie wyglądać następująco:</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="k">template</span><span class="w"> </span><span class="o">&lt;</span><span class="k">typename</span><span class="w"> </span><span class="nc">T</span><span class="o">&gt;</span><span class="w"> </span><span class="n">S</span><span class="p">(</span><span class="n">T</span><span class="p">)</span><span class="w"> </span><span class="o">-&gt;</span><span class="w"> </span><span class="n">S</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span><span class="p">;</span><span class="w"> </span><span class="c1">// implicit deduction guide</span>
</pre></div>
</div>
<p>W rezultacie programista nie musi implementować jej jawnie.</p>
</section>
<section id="specjalny-przypadek-dedukcji-argumentow-klasy-szablonowej">
<h3>Specjalny przypadek dedukcji argumentów klasy szablonowej<a class="headerlink" href="#specjalny-przypadek-dedukcji-argumentow-klasy-szablonowej" title="Link to this heading">#</a></h3>
<p>Rozważmy następujący przypadek dedukcji:</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="n">S</span><span class="w"> </span><span class="n">x</span><span class="p">{</span><span class="mi">42</span><span class="p">};</span><span class="w"> </span><span class="c1">// x has type S&lt;int&gt;</span>

<span class="n">S</span><span class="w"> </span><span class="n">y</span><span class="p">{</span><span class="n">x</span><span class="p">};</span>
<span class="n">S</span><span class="w"> </span><span class="nf">z</span><span class="p">(</span><span class="n">x</span><span class="p">);</span>
</pre></div>
</div>
<p>W obu przypadkach dedukowany typ zmiennych <code class="docutils literal notranslate"><span class="pre">y</span></code> i <code class="docutils literal notranslate"><span class="pre">z</span></code> to <code class="docutils literal notranslate"><span class="pre">S&lt;int&gt;</span></code>. Mechanizm dedukcji argumentów klasy szablonowej
dedukuje typ taki sam jak typ oryginalnego obiektu a następnie wywoływany jest konstruktor kopiujący.</p>
<ul class="simple">
<li><p>dla deklaracji <code class="docutils literal notranslate"><span class="pre">S&lt;T&gt;</span> <span class="pre">x;</span></code>
<code class="docutils literal notranslate"><span class="pre">S{x}</span></code> dedukuje typ: <code class="docutils literal notranslate"><span class="pre">S&lt;T&gt;{x}</span></code> zamiast <code class="docutils literal notranslate"><span class="pre">S&lt;S&lt;T&gt;&gt;{x}</span></code></p></li>
</ul>
<p>W niektórych przypadkach może być to zaskakujące i kontrowersyjne:</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="w"> </span><span class="n">v</span><span class="p">{</span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="mi">2</span><span class="p">,</span><span class="w"> </span><span class="mi">3</span><span class="p">};</span><span class="w"> </span><span class="c1">// vector&lt;int&gt;</span>
<span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="w"> </span><span class="n">data1</span><span class="p">{</span><span class="n">v</span><span class="p">,</span><span class="w"> </span><span class="n">v</span><span class="p">};</span><span class="w"> </span><span class="c1">// vector&lt;vector&lt;int&gt;&gt;</span>
<span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="w"> </span><span class="n">data2</span><span class="p">{</span><span class="n">v</span><span class="p">};</span><span class="w"> </span><span class="c1">// vector&lt;int&gt;!</span>
</pre></div>
</div>
<p>W powyższym kodzie dedukcja argumentów szablonu <code class="docutils literal notranslate"><span class="pre">vector</span></code> zależy od ilości argumentów przekazanych do konstruktora!</p>
</section>
<section id="agregaty-a-dedukcja-argumentow">
<h3>Agregaty a dedukcja argumentów<a class="headerlink" href="#agregaty-a-dedukcja-argumentow" title="Link to this heading">#</a></h3>
<p>Jeśli szablon klasy jest agregatem, to mechanizm automatycznej dedukcji argumentów szablonu wymaga napisania jawnej podpowiedzi dedukcyjnej.</p>
<p>Bez podpowiedzi dedukcyjnej dedukcja dla agregatów nie działa:</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="k">template</span><span class="w"> </span><span class="o">&lt;</span><span class="k">typename</span><span class="w"> </span><span class="nc">T</span><span class="o">&gt;</span>
<span class="k">struct</span><span class="w"> </span><span class="nc">Aggregate1</span>
<span class="p">{</span>
<span class="w">    </span><span class="n">T</span><span class="w"> </span><span class="n">value</span><span class="p">;</span>
<span class="p">};</span>

<span class="n">Aggregate1</span><span class="w"> </span><span class="n">agg1</span><span class="p">{</span><span class="mi">8</span><span class="p">};</span><span class="w"> </span><span class="c1">// ERROR</span>
<span class="n">Aggregate1</span><span class="w"> </span><span class="n">agg2</span><span class="p">{</span><span class="s">&quot;eight&quot;</span><span class="p">};</span><span class="w"> </span><span class="c1">// ERROR</span>
<span class="n">Aggregate1</span><span class="w"> </span><span class="n">agg3</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mf">3.14</span><span class="p">;</span><span class="w"> </span><span class="c1">// ERROR</span>
</pre></div>
</div>
<p>Gdy napiszemy dla agregatu podpowiedź, to możemy zacząć korzystać z mechanizmu dedukcji:</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="k">template</span><span class="w"> </span><span class="o">&lt;</span><span class="k">typename</span><span class="w"> </span><span class="nc">T</span><span class="o">&gt;</span>
<span class="k">struct</span><span class="w"> </span><span class="nc">Aggregate2</span>
<span class="p">{</span>
<span class="w">    </span><span class="n">T</span><span class="w"> </span><span class="n">value</span><span class="p">;</span>
<span class="p">};</span>

<span class="k">template</span><span class="w"> </span><span class="o">&lt;</span><span class="k">typename</span><span class="w"> </span><span class="nc">T</span><span class="o">&gt;</span>
<span class="n">Aggregate2</span><span class="p">(</span><span class="n">T</span><span class="p">)</span><span class="w"> </span><span class="o">-&gt;</span><span class="w"> </span><span class="n">Aggregate2</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span><span class="p">;</span>

<span class="n">Aggregate2</span><span class="w"> </span><span class="n">agg1</span><span class="p">{</span><span class="mi">8</span><span class="p">};</span><span class="w"> </span><span class="c1">// OK -&gt; Aggregate2&lt;int&gt;</span>
<span class="n">Aggregate2</span><span class="w"> </span><span class="n">agg2</span><span class="p">{</span><span class="s">&quot;eight&quot;</span><span class="p">};</span><span class="w"> </span><span class="c1">// OK -&gt; Aggregate2&lt;const char*&gt;</span>
<span class="n">Aggregate2</span><span class="w"> </span><span class="n">agg3</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="mf">3.14</span><span class="w"> </span><span class="p">};</span><span class="w"> </span><span class="c1">// OK -&gt; Aggregate2&lt;double&gt;</span>
</pre></div>
</div>
</section>
<section id="podpowiedzi-dedukcyjne-w-bibliotece-standardowej">
<h3>Podpowiedzi dedukcyjne w bibliotece standardowej<a class="headerlink" href="#podpowiedzi-dedukcyjne-w-bibliotece-standardowej" title="Link to this heading">#</a></h3>
<p>Dla wielu klas szablonowych z biblioteki standardowej dodano podpowiedzi dedukcyjne w celu ułatwienia tworzenia instancji tych klas.</p>
<section id="std-pair">
<h4>std::pair<T><a class="headerlink" href="#std-pair" title="Link to this heading">#</a></h4>
<p>Dla pary STL dodana w standardzie podpowiedź to:</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="k">template</span><span class="o">&lt;</span><span class="k">class</span><span class="w"> </span><span class="nc">T1</span><span class="p">,</span><span class="w"> </span><span class="k">class</span><span class="w"> </span><span class="nc">T2</span><span class="o">&gt;</span>
<span class="n">pair</span><span class="p">(</span><span class="n">T1</span><span class="p">,</span><span class="w"> </span><span class="n">T2</span><span class="p">)</span><span class="w"> </span><span class="o">-&gt;</span><span class="w"> </span><span class="n">pair</span><span class="o">&lt;</span><span class="n">T1</span><span class="p">,</span><span class="w"> </span><span class="n">T2</span><span class="o">&gt;</span><span class="p">;</span>

<span class="n">pair</span><span class="w"> </span><span class="nf">p1</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="mf">3.14</span><span class="p">);</span><span class="w"> </span><span class="c1">// -&gt; pair&lt;int, double&gt;</span>

<span class="n">pair</span><span class="w"> </span><span class="n">p2</span><span class="p">{</span><span class="mf">3.14f</span><span class="p">,</span><span class="w"> </span><span class="s">&quot;text&quot;</span><span class="n">s</span><span class="p">};</span><span class="w"> </span><span class="c1">// -&gt; pair&lt;float, string&gt;</span>

<span class="n">pair</span><span class="w"> </span><span class="n">p3</span><span class="p">{</span><span class="mf">3.14f</span><span class="p">,</span><span class="w"> </span><span class="s">&quot;text&quot;</span><span class="p">};</span><span class="w"> </span><span class="c1">// -&gt; pair&lt;float, const char*&gt;</span>

<span class="kt">int</span><span class="w"> </span><span class="n">tab</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="mi">2</span><span class="p">,</span><span class="w"> </span><span class="mi">3</span><span class="w"> </span><span class="p">};</span>
<span class="n">pair</span><span class="w"> </span><span class="n">p4</span><span class="p">{</span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="n">tab</span><span class="p">};</span><span class="w"> </span><span class="c1">// -&gt; pair&lt;int, int*&gt;</span>
</pre></div>
</div>
</section>
<section id="std-tuple-t">
<h4>std::tuple&lt;T…&gt;<a class="headerlink" href="#std-tuple-t" title="Link to this heading">#</a></h4>
<p>Szablon <code class="docutils literal notranslate"><span class="pre">std::tuple</span></code> jest traktowany podobnie jak <code class="docutils literal notranslate"><span class="pre">std::pair</span></code>:</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="k">template</span><span class="o">&lt;</span><span class="k">class</span><span class="p">...</span><span class="w"> </span><span class="n">UTypes</span><span class="o">&gt;</span>
<span class="n">tuple</span><span class="p">(</span><span class="n">UTypes</span><span class="p">...)</span><span class="w"> </span><span class="o">-&gt;</span><span class="w"> </span><span class="n">tuple</span><span class="o">&lt;</span><span class="n">UTypes</span><span class="p">...</span><span class="o">&gt;</span><span class="p">;</span>

<span class="k">template</span><span class="o">&lt;</span><span class="k">class</span><span class="w"> </span><span class="nc">T1</span><span class="p">,</span><span class="w"> </span><span class="k">class</span><span class="w"> </span><span class="nc">T2</span><span class="o">&gt;</span>
<span class="n">tuple</span><span class="p">(</span><span class="n">pair</span><span class="o">&lt;</span><span class="n">T1</span><span class="p">,</span><span class="w"> </span><span class="n">T2</span><span class="o">&gt;</span><span class="p">)</span><span class="w"> </span><span class="o">-&gt;</span><span class="w"> </span><span class="n">tuple</span><span class="o">&lt;</span><span class="n">T1</span><span class="p">,</span><span class="w"> </span><span class="n">T2</span><span class="o">&gt;</span><span class="p">;</span>

<span class="c1">//... other deduction guides working with allocators</span>

<span class="kt">int</span><span class="w"> </span><span class="n">x</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">10</span><span class="p">;</span>
<span class="k">const</span><span class="w"> </span><span class="kt">int</span><span class="o">&amp;</span><span class="w"> </span><span class="n">cref_x</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">x</span><span class="p">;</span>

<span class="n">tuple</span><span class="w"> </span><span class="n">t1</span><span class="p">{</span><span class="n">x</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="n">x</span><span class="p">,</span><span class="w"> </span><span class="n">cref_x</span><span class="p">,</span><span class="w"> </span><span class="s">&quot;hello&quot;</span><span class="p">,</span><span class="w"> </span><span class="s">&quot;world&quot;</span><span class="n">s</span><span class="p">};</span><span class="w"> </span><span class="o">-&gt;</span><span class="w"> </span><span class="n">tuple</span><span class="o">&lt;</span><span class="kt">int</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="o">*</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="p">,</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="kt">char</span><span class="o">*</span><span class="p">,</span><span class="w"> </span><span class="n">string</span><span class="o">&gt;</span>
</pre></div>
</div>
</section>
<section id="std-optional">
<h4>std::optional<T><a class="headerlink" href="#std-optional" title="Link to this heading">#</a></h4>
<p>Klasa <code class="docutils literal notranslate"><span class="pre">std::optional</span></code> jest traktowana podobnie do pary i krotki.</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="k">template</span><span class="o">&lt;</span><span class="k">class</span><span class="w"> </span><span class="nc">T</span><span class="o">&gt;</span><span class="w"> </span><span class="n">optional</span><span class="p">(</span><span class="n">T</span><span class="p">)</span><span class="w"> </span><span class="o">-&gt;</span><span class="w"> </span><span class="n">optional</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span><span class="p">;</span>

<span class="n">optional</span><span class="w"> </span><span class="nf">o1</span><span class="p">(</span><span class="mi">3</span><span class="p">);</span><span class="w"> </span><span class="c1">// -&gt; optional&lt;int&gt;</span>
<span class="n">optional</span><span class="w"> </span><span class="n">o2</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">o1</span><span class="p">;</span><span class="w"> </span><span class="c1">// -&gt; optional&lt;int&gt;</span>
</pre></div>
</div>
</section>
<section id="inteligentne-wskazniki">
<h4>Inteligentne wskaźniki<a class="headerlink" href="#inteligentne-wskazniki" title="Link to this heading">#</a></h4>
<p>Dedukcja dla argumentów konstruktora będących wskaźnikami jest zablokowana:</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="kt">int</span><span class="o">*</span><span class="w"> </span><span class="n">ptr</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">new</span><span class="w"> </span><span class="kt">int</span><span class="p">{</span><span class="mi">5</span><span class="p">};</span>
<span class="n">unique_ptr</span><span class="w"> </span><span class="n">uptr</span><span class="p">{</span><span class="n">ip</span><span class="p">};</span><span class="w"> </span><span class="c1">// ERROR - ill-formed (due to array type clash)</span>
</pre></div>
</div>
<p>Wspierana jest dedukcja przy konwersjach:</p>
<ul>
<li><p>z <code class="docutils literal notranslate"><span class="pre">weak_ptr</span></code>/<code class="docutils literal notranslate"><span class="pre">unique_ptr</span></code> do <code class="docutils literal notranslate"><span class="pre">shared_ptr</span></code>:</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="k">template</span><span class="w"> </span><span class="o">&lt;</span><span class="k">class</span><span class="w"> </span><span class="nc">T</span><span class="o">&gt;</span><span class="w"> </span><span class="n">shared_ptr</span><span class="p">(</span><span class="n">weak_ptr</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span><span class="p">)</span><span class="w"> </span><span class="o">-&gt;</span><span class="w">  </span><span class="n">shared_ptr</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span><span class="p">;</span>
<span class="k">template</span><span class="w"> </span><span class="o">&lt;</span><span class="k">class</span><span class="w"> </span><span class="nc">T</span><span class="p">,</span><span class="w"> </span><span class="k">class</span><span class="w"> </span><span class="nc">D</span><span class="o">&gt;</span><span class="w"> </span><span class="n">shared_ptr</span><span class="p">(</span><span class="n">unique_ptr</span><span class="o">&lt;</span><span class="n">T</span><span class="p">,</span><span class="w"> </span><span class="n">D</span><span class="o">&gt;</span><span class="p">)</span><span class="w"> </span><span class="o">-&gt;</span><span class="w">  </span><span class="n">shared_ptr</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span><span class="p">;</span>
</pre></div>
</div>
</li>
<li><p>z <code class="docutils literal notranslate"><span class="pre">shared_ptr</span></code> do <code class="docutils literal notranslate"><span class="pre">weak_ptr</span></code></p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="k">template</span><span class="o">&lt;</span><span class="k">class</span><span class="w"> </span><span class="nc">T</span><span class="o">&gt;</span><span class="w"> </span><span class="n">weak_ptr</span><span class="p">(</span><span class="n">shared_ptr</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span><span class="p">)</span><span class="w"> </span><span class="o">-&gt;</span><span class="w"> </span><span class="n">weak_ptr</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span><span class="p">;</span>
</pre></div>
</div>
</li>
</ul>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="n">unique_ptr</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span><span class="w"> </span><span class="n">uptr</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">make_unique</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span><span class="p">(</span><span class="mi">3</span><span class="p">);</span>

<span class="n">shared_ptr</span><span class="w"> </span><span class="n">sptr</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">move</span><span class="p">(</span><span class="n">uptr</span><span class="p">);</span><span class="w"> </span><span class="o">-&gt;</span><span class="w"> </span><span class="n">shared_ptr</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span>
<span class="w">    </span>
<span class="n">weak_ptr</span><span class="w"> </span><span class="n">wptr</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">sptr</span><span class="p">;</span><span class="w"> </span><span class="c1">// -&gt; weak_prt&lt;int&gt;</span>

<span class="n">shared_ptr</span><span class="w"> </span><span class="n">sptr2</span><span class="p">{</span><span class="n">wptr</span><span class="p">};</span><span class="w"> </span><span class="c1">// -&gt; shared_ptr&lt;int&gt;</span>
</pre></div>
</div>
</section>
<section id="std-function">
<h4>std::function<a class="headerlink" href="#std-function" title="Link to this heading">#</a></h4>
<p>Dozwolone jest dedukowanie sygnatur funkcji dla <code class="docutils literal notranslate"><span class="pre">std::function</span></code>:</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="kt">int</span><span class="w"> </span><span class="nf">add</span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">x</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">y</span><span class="p">)</span>
<span class="p">{</span>
<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="n">x</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">y</span><span class="p">;</span>
<span class="p">}</span>

<span class="n">function</span><span class="w"> </span><span class="n">f1</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="o">&amp;</span><span class="n">add</span><span class="p">;</span>
<span class="n">assert</span><span class="p">(</span><span class="n">f1</span><span class="p">(</span><span class="mi">4</span><span class="p">,</span><span class="w"> </span><span class="mi">5</span><span class="p">)</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="mi">9</span><span class="p">);</span>

<span class="n">function</span><span class="w"> </span><span class="n">f2</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">[](</span><span class="k">const</span><span class="w"> </span><span class="n">string</span><span class="o">&amp;</span><span class="w"> </span><span class="n">txt</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="n">cout</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">txt</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="s">&quot; from lambda!&quot;</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">endl</span><span class="p">;</span><span class="w"> </span><span class="p">};</span>
<span class="n">f2</span><span class="p">(</span><span class="s">&quot;Hello&quot;</span><span class="p">);</span>
</pre></div>
</div>
</section>
<section id="kontenery-i-sekwencje">
<h4>Kontenery i sekwencje<a class="headerlink" href="#kontenery-i-sekwencje" title="Link to this heading">#</a></h4>
<p>Dla kontenerów standardowych dozwolona jest dedukcja typu kontenera dla konstruktora akceptującego parę iteratorów:</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span><span class="w"> </span><span class="n">vec</span><span class="p">{</span><span class="w"> </span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="mi">2</span><span class="p">,</span><span class="w"> </span><span class="mi">3</span><span class="w"> </span><span class="p">};</span>
<span class="n">list</span><span class="w"> </span><span class="nf">lst</span><span class="p">(</span><span class="n">vec</span><span class="p">.</span><span class="n">begin</span><span class="p">(),</span><span class="w"> </span><span class="n">vec</span><span class="p">.</span><span class="n">end</span><span class="p">());</span><span class="w"> </span><span class="c1">// -&gt; list&lt;int&gt;</span>
</pre></div>
</div>
<p>Dla <code class="docutils literal notranslate"><span class="pre">std::array</span></code> dozwolona jest dedukcja z sekwencji:</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="n">std</span><span class="o">::</span><span class="n">array</span><span class="w"> </span><span class="n">arr1</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="mi">2</span><span class="p">,</span><span class="w"> </span><span class="mi">3</span><span class="w"> </span><span class="p">};</span><span class="w"> </span><span class="c1">// -&gt; std::array&lt;int, 3&gt;</span>
</pre></div>
</div>
</section>
</section>
</section>
</section>

    <script type="text/x-thebe-config">
    {
        requestKernel: true,
        binderOptions: {
            repo: "binder-examples/jupyter-stacks-datascience",
            ref: "master",
        },
        codeMirrorConfig: {
            theme: "abcdef",
            mode: "python"
        },
        kernelOptions: {
            name: "python3",
            path: "./."
        },
        predefinedOutput: true
    }
    </script>
    <script>kernelName = 'python3'</script>

                </article>
              

              
              
              
              
                <footer class="prev-next-footer d-print-none">
                  
<div class="prev-next-area">
    <a class="left-prev"
       href="function-templates.html"
       title="previous page">
      <i class="fa-solid fa-angle-left"></i>
      <div class="prev-next-info">
        <p class="prev-next-subtitle">previous</p>
        <p class="prev-next-title">Szablony funkcji</p>
      </div>
    </a>
    <a class="right-next"
       href="aliases.html"
       title="next page">
      <div class="prev-next-info">
        <p class="prev-next-subtitle">next</p>
        <p class="prev-next-title">Aliasy szablonów</p>
      </div>
      <i class="fa-solid fa-angle-right"></i>
    </a>
</div>
                </footer>
              
            </div>
            
            
              
                <div class="bd-sidebar-secondary bd-toc"><div class="sidebar-secondary-items sidebar-secondary__inner">


  <div class="sidebar-secondary-item">
  <div class="page-toc tocsection onthispage">
    <i class="fa-solid fa-list"></i> Contents
  </div>
  <nav class="bd-toc-nav page-toc">
    <ul class="visible nav section-nav flex-column">
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#podstawowa-skladnia">Podstawowa składnia</a><ul class="nav section-nav flex-column">
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#definicja-szablonu-klasy">Definicja szablonu klasy</a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#implementacja-funkcji-skladowych-poza-cialem-klasy">Implementacja funkcji składowych poza ciałem klasy</a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#tworzenie-instancji-szablonu-klasy">Tworzenie instancji szablonu klasy</a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#przyklad-uzycia">Przykład użycia</a></li>
</ul>
</li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#parametry-szablonow-klas">Parametry szablonów klas</a><ul class="nav section-nav flex-column">
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#parametry-typu">1. Parametry typu</a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#parametry-niebedace-typami-nttp">2. Parametry niebędące typami - NTTP</a><ul class="nav section-nav flex-column">
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#dopuszczalne-parametry-nttp">Dopuszczalne parametry NTTP</a></li>
</ul>
</li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#szablony-jako-parametry-szablonow">3. Szablony jako parametry szablonów</a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#parametry-domyslne">Parametry domyślne</a></li>
</ul>
</li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#specjalizacja-szablonow-klas">Specjalizacja szablonów klas</a><ul class="nav section-nav flex-column">
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#pelna-specjalizacja-szablonu-klasy">Pełna specjalizacja szablonu klasy</a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#specjalizacja-czesciowa-szablonu-klasy">Specjalizacja częściowa szablonu klasy</a></li>
</ul>
</li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#skladowe-jako-szablony">Składowe jako szablony</a></li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#dedukcja-argumentow-szablonu-dla-klas">Dedukcja argumentów szablonu dla klas</a><ul class="nav section-nav flex-column">
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#podpowiedzi-dedukcyjne-deduction-guides">Podpowiedzi dedukcyjne (<em>deduction guides</em>)</a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#niejawne-podpowiedzi-dedukcyjne">Niejawne podpowiedzi dedukcyjne</a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#specjalny-przypadek-dedukcji-argumentow-klasy-szablonowej">Specjalny przypadek dedukcji argumentów klasy szablonowej</a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#agregaty-a-dedukcja-argumentow">Agregaty a dedukcja argumentów</a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#podpowiedzi-dedukcyjne-w-bibliotece-standardowej">Podpowiedzi dedukcyjne w bibliotece standardowej</a><ul class="nav section-nav flex-column">
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#std-pair">std::pair<t></t></a></li>
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#std-tuple-t">std::tuple&lt;T…&gt;</a></li>
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#std-optional">std::optional<t></t></a></li>
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#inteligentne-wskazniki">Inteligentne wskaźniki</a></li>
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#std-function">std::function</a></li>
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#kontenery-i-sekwencje">Kontenery i sekwencje</a></li>
</ul>
</li>
</ul>
</li>
</ul>
  </nav></div>

</div></div>
              
            
          </div>
          <footer class="bd-footer-content">
            
<div class="bd-footer-content__inner container">
  
  <div class="footer-item">
    
<p class="component-author">
By Krystian Piękoś - Infotraining
</p>

  </div>
  
  <div class="footer-item">
    

  <p class="copyright">
    
      © Copyright 2023.
      <br/>
    
  </p>

  </div>
  
  <div class="footer-item">
    
  </div>
  
  <div class="footer-item">
    
  </div>
  
</div>
          </footer>
        

      </main>
    </div>
  </div>
  
  <!-- Scripts loaded after <body> so the DOM is not blocked -->
  <script src="_static/scripts/bootstrap.js?digest=3ee479438cf8b5e0d341"></script>
<script src="_static/scripts/pydata-sphinx-theme.js?digest=3ee479438cf8b5e0d341"></script>

  <footer class="bd-footer">
  </footer>
  </body>
</html>